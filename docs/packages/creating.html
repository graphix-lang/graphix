<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Creating Packages - The Graphix Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Graphix Programming Language</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="creating-packages"><a class="header" href="#creating-packages">Creating Packages</a></h1>
<h2 id="scaffolding-a-new-package"><a class="header" href="#scaffolding-a-new-package">Scaffolding a New Package</a></h2>
<p>Create a new package with:</p>
<pre><code>graphix package create mylib
</code></pre>
<p>Or specify a directory:</p>
<pre><code>graphix package create mylib --dir ~/projects
</code></pre>
<p>This creates a <code>graphix-package-mylib</code> directory with the following structure:</p>
<pre><code>graphix-package-mylib/
  Cargo.toml
  README.md
  src/
    lib.rs
    graphix/
      mod.gx
      mod.gxi
</code></pre>
<h2 id="package-structure"><a class="header" href="#package-structure">Package Structure</a></h2>
<h3 id="srclibrs----the-rust-entry-point"><a class="header" href="#srclibrs----the-rust-entry-point"><code>src/lib.rs</code> -- The Rust Entry Point</a></h3>
<p>The heart of a package is <code>src/lib.rs</code>, which uses the <code>defpackage!</code> macro to
declare the package:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use graphix_derive::defpackage;
use graphix_package_core::{CachedArgs, CachedVals, EvalCached};

// ... builtin implementations ...

defpackage! {
    builtins =&gt; [
        MyBuiltin,
        MyCachedBuiltin,
    ]
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>defpackage!</code> macro generates:</p>
<ul>
<li>A <code>pub struct P</code> that implements the <code>Package</code> trait</li>
<li>Registration code for all listed builtins</li>
<li>Automatic inclusion of all <code>.gx</code> and <code>.gxi</code> files from <code>src/graphix/</code></li>
<li>Test infrastructure (<code>TEST_REGISTER</code>) for the test harness</li>
</ul>
<h3 id="srcgraphix----graphix-source-modules"><a class="header" href="#srcgraphix----graphix-source-modules"><code>src/graphix/</code> -- Graphix Source Modules</a></h3>
<p>Graphix source files in <code>src/graphix/</code> are automatically included in the
package. These files provide the Graphix-level API for your package. The
directory structure maps to the module hierarchy: <code>src/graphix/foo.gx</code> becomes
the module <code>mylib::foo</code> (note you still need <code>mod foo</code> in mod.gx).</p>
<p>The top-level module file is <code>src/graphix/mod.gx</code>. This is where you typically
bind your builtins to Graphix names and re-export them:</p>
<pre><code class="language-graphix">let my_builtin = |arg| 'mylib_my_builtin;
let my_cached = |@args| 'mylib_my_cached;
</code></pre>
<h3 id="srcgraphixmodgxi----interface-file"><a class="header" href="#srcgraphixmodgxi----interface-file"><code>src/graphix/mod.gxi</code> -- Interface File</a></h3>
<p>The interface file declares the public API of your package:</p>
<pre><code class="language-graphix">/// Check if a value is an error
val my_builtin: fn(Any) -&gt; bool;

/// Logical OR of all arguments
val my_cached: fn(@args: bool) -&gt; bool;
</code></pre>
<p>See <a href="../modules/interfaces.html">Interface Files</a> for the full interface syntax.</p>
<h2 id="writing-built-in-functions"><a class="header" href="#writing-built-in-functions">Writing Built-in Functions</a></h2>
<p>There are two ways to write builtins: the simplified <code>CachedArgs</code> interface for
pure functions, and the full <code>BuiltIn</code> + <code>Apply</code> traits for functions that need
fine-grained control over the update cycle.</p>
<h3 id="naming-convention"><a class="header" href="#naming-convention">Naming Convention</a></h3>
<p>All builtin names <strong>must</strong> start with your package name. For a package named
<code>mylib</code>, builtins must be named <code>mylib_something</code>. The <code>defpackage!</code> macro
enforces this at compile time.</p>
<h3 id="the-simple-path-evalcached--cachedargs"><a class="header" href="#the-simple-path-evalcached--cachedargs">The Simple Path: <code>EvalCached</code> / <code>CachedArgs</code></a></h3>
<p>For pure functions that just compute a result from their arguments, use
<code>EvalCached</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use graphix_package_core::{deftype, CachedArgs, CachedVals, EvalCached};
use netidx_value::Value;

#[derive(Debug, Default)]
struct MyMinEv;

impl EvalCached for MyMinEv {
    const NAME: &amp;str = "mylib_min";
    deftype!("fn('a, @args: 'a) -&gt; 'a");

    fn eval(&amp;mut self, from: &amp;CachedVals) -&gt; Option&lt;Value&gt; {
        let mut res = None;
        for v in from.flat_iter() {
            match (res, v) {
                (None, None) | (Some(_), None) =&gt; return None,
                (None, Some(v)) =&gt; res = Some(v),
                (Some(v0), Some(v)) =&gt; {
                    res = if v &lt; v0 { Some(v) } else { Some(v0) };
                }
            }
        }
        res
    }
}

type MyMin = CachedArgs&lt;MyMinEv&gt;;
<span class="boring">}</span></code></pre></pre>
<p>Then list <code>MyMin</code> in your <code>defpackage!</code> builtins. <code>CachedArgs</code> handles all the
details of caching argument values, calling <code>eval</code> when arguments change, and
implementing the <code>Apply</code> trait.</p>
<h3 id="the-full-control-path-builtin--apply"><a class="header" href="#the-full-control-path-builtin--apply">The Full-Control Path: <code>BuiltIn</code> + <code>Apply</code></a></h3>
<p>For builtins that need to interact with the execution context, manage internal
state across cycles, or work with higher-order functions, implement the
<code>BuiltIn</code> and <code>Apply</code> traits directly. See
<a href="../embedding/builtins.html">Writing Built in Functions</a> for a deep dive.</p>
<p>Here is a minimal example -- <code>once</code> passes through exactly one update:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result;
use graphix_compiler::{
    expr::ExprId, typ::FnType, Apply, BuiltIn, Event, ExecCtx, Node, Rt, Scope, UserEvent,
};
use graphix_package_core::deftype;
use netidx_value::Value;

#[derive(Debug)]
struct MyOnce {
    val: bool,
}

impl&lt;R: Rt, E: UserEvent&gt; BuiltIn&lt;R, E&gt; for MyOnce {
    const NAME: &amp;str = "mylib_once";
    deftype!("fn('a) -&gt; 'a");

    fn init&lt;'a, 'b, 'c&gt;(
        _ctx: &amp;'a mut ExecCtx&lt;R, E&gt;,
        _typ: &amp;'a FnType,
        _scope: &amp;'b Scope,
        _from: &amp;'c [Node&lt;R, E&gt;],
        _top_id: ExprId,
    ) -&gt; Result&lt;Box&lt;dyn Apply&lt;R, E&gt;&gt;&gt; {
        Ok(Box::new(MyOnce { val: false }))
    }
}

impl&lt;R: Rt, E: UserEvent&gt; Apply&lt;R, E&gt; for MyOnce {
    fn update(
        &amp;mut self,
        ctx: &amp;mut ExecCtx&lt;R, E&gt;,
        from: &amp;mut [Node&lt;R, E&gt;],
        event: &amp;mut Event&lt;E&gt;,
    ) -&gt; Option&lt;Value&gt; {
        match from {
            [s] =&gt; s.update(ctx, event).and_then(|v| {
                if self.val {
                    None
                } else {
                    self.val = true;
                    Some(v)
                }
            }),
            _ =&gt; None,
        }
    }

    fn sleep(&amp;mut self, _ctx: &amp;mut ExecCtx&lt;R, E&gt;) {
        self.val = false
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="generic-builtins"><a class="header" href="#generic-builtins">Generic Builtins</a></h3>
<p>If your builtin's type is parameterized over the runtime types <code>R</code> and <code>E</code>, use
the <code>as</code> syntax in the builtins list:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>defpackage! {
    builtins =&gt; [
        MyGeneric as MyGeneric&lt;GXRt&lt;X&gt;, X::UserEvent&gt;,
    ]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-displays"><a class="header" href="#custom-displays">Custom Displays</a></h2>
<p>Packages can provide custom display implementations. Custom displays allow you
to do something special with a value returned to the shell by a script or in the
REPL. For example the TUI package uses a custom display to take control of the
terminal and render a terminal UI from the returned value.</p>
<h3 id="the-customdisplay-trait"><a class="header" href="#the-customdisplay-trait">The <code>CustomDisplay</code> Trait</a></h3>
<p>A custom display implements <code>CustomDisplay&lt;X&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait CustomDisplay&lt;X: GXExt&gt;: Any {
    /// Called when the shell wants to return to normal display mode,
    /// or when the custom display signals stop. Free any resources here.
    async fn clear(&amp;mut self);

    /// Called on every update from the Graphix runtime.
    /// This includes all updates, not just ones related to the custom
    /// display. The future returned must resolve promptly or the shell
    /// will hang.
    async fn process_update(&amp;mut self, env: &amp;Env, id: ExprId, v: Value);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="registering-a-custom-display"><a class="header" href="#registering-a-custom-display">Registering a Custom Display</a></h3>
<p>To hook a custom display into the shell, provide <code>is_custom</code> and <code>init_custom</code>
closures in <code>defpackage!</code>:</p>
<ul>
<li><strong><code>is_custom</code></strong> receives each compiled expression and returns <code>true</code> if your
package should handle its display. The shell calls this to decide whether to
use the default display or delegate to your package.</li>
<li><strong><code>init_custom</code></strong> constructs your <code>CustomDisplay</code>. It receives a <code>stop</code>
channel â€” send on it when the display wants to exit (e.g. the user closed a
window), and the shell will call <code>clear()</code> before dropping the display.</li>
</ul>
<p>Here is a minimal example that prints every update to stderr:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_trait::async_trait;
use graphix_compiler::{env::Env, expr::ExprId};
use graphix_package::CustomDisplay;
use graphix_rt::GXExt;
use netidx_value::Value;

struct DebugDisplay;

#[async_trait]
impl&lt;X: GXExt&gt; CustomDisplay&lt;X&gt; for DebugDisplay {
    async fn clear(&amp;mut self) {
        eprintln!("[debug display] cleared");
    }

    async fn process_update(&amp;mut self, _env: &amp;Env, id: ExprId, v: Value) {
        eprintln!("[debug display] {id:?} = {v}");
    }
}

defpackage! {
    builtins =&gt; [...],
    is_custom =&gt; |_gx, _env, e| {
        // claim all expressions whose result type is an array
        e.typ.with_deref(|t| {
            matches!(t, Some(graphix_compiler::typ::Type::Array(_)))
        })
    },
    init_custom =&gt; |_gx, _env, _stop, _e| {
        Ok(Box::new(DebugDisplay))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>e</code> parameter is a <code>CompExp</code> which has a <code>typ</code> field (the inferred result
type) and an <code>id</code> field (the expression ID). Typically <code>is_custom</code> checks
whether the result type matches something your display knows how to render, as
the TUI package does with its widget types. The custom display is responsible
for keeping the CompExp alive (if that is necessary), if it is dropped the
expression will be removed from the runtime (just like any other dropped
CompExp).</p>
<h2 id="dependencies-between-packages"><a class="header" href="#dependencies-between-packages">Dependencies Between Packages</a></h2>
<p>Packages can depend on other packages via Cargo. Add the dependency to your
<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
graphix-package-core = "0.3"
graphix-package-time = "0.3"
</code></pre>
<p>Your package's <code>register()</code> function (generated by <code>defpackage!</code>) automatically
calls <code>register()</code> on all its <code>graphix-package-*</code> dependencies before
registering itself. This ensures transitive dependencies are always available.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>The <code>defpackage!</code> macro generates a <code>TEST_REGISTER</code> constant that includes
register functions for all package dependencies. Use the test macros from
<code>graphix-package-core</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use graphix_package_core::run;

    run!(my_test, "mylib::my_builtin(true)", |r| {
        matches!(r, Ok(netidx::subscriber::Value::Bool(true)))
    });
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>run!</code> macro sets up a full Graphix runtime with your package registered,
compiles the expression, and checks the result against your predicate.</p>
<h2 id="publishing"><a class="header" href="#publishing">Publishing</a></h2>
<p>Packages are published to crates.io like any other Rust crate:</p>
<pre><code>cd graphix-package-mylib
cargo publish
</code></pre>
<p>Once published, anyone can install it with <code>graphix package add mylib</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../packages/using.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../packages/standalone.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../packages/using.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../packages/standalone.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/graphix-highlight.js"></script>


    </div>
    </body>
</html>
