<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Graphix Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Graphix Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro-to-graphix"><a class="header" href="#intro-to-graphix">Intro to Graphix</a></h1>
<p>The first goal of Graphix is to make it easy to build user interfaces to
display, interact with, and control resources published in
<a href="https://netidx.github.io/netidx-book">netidx</a>(The second goal is to be the
weirdest practical language on earth). As such graphix is a "reactive" or
dataflow language. Instead of compiling to machine code, or bytecode like other
languages graphix programs compile to a directed graph. Operations like + are
graph nodes, and edges represent paths between nodes that data can take. Running
the program means starting the flow of data into the graph so that it will flow
through, and be transformed by, the nodes of the graph. Consider,</p>
<pre><code>let x = cast&lt;i64&gt;(net::subscribe("/foo")?)?;
print(x * 10)
</code></pre>
<p>net::subscribe, subscribes to a netidx path and returns it's value, or an error
(more on ? later). If you read this like a "normal" functional or imperative
program, it appears to get the current value of "/foo", multiply it by 10 and
print the result, no other explanation really makes sense. However in the dataflow paradigm, this compiles to a graph,</p>
<pre><code>                                   const(10) ==
                                                |
                                                |
                                                v
const("/foo") =&gt; net::subscribe =&gt; cast&lt;i64&gt; =&gt; * =&gt; print
</code></pre>
<p>net::subscribe's value will change when the value in netidx changes, and that
new value will flow through the graph and be transformed by all the nodes it
passes through. So in graphix, this program will print the current value of
"/foo" in netix multiplied by 10, and when that value changes it will print an
updated value.</p>
<p>This is a powerful way to think about programming, and it's especially well
suited to building user interfaces and transforming data streams, as we will see
in this book.</p>
<p>In all other respects Graphix aims to be a normal language that would feel
familair to anyone who knows OCaml, Rust, Haskell, or another similar modern
language.</p>
<ul>
<li>It is lexically scoped</li>
<li>It is expression oriented, every language construct is an expression that
results in a value</li>
<li>It is strongly statically typed, using type erasure on top of a flexible
universal variant type. Making it both good at catching errors at compile
time, and flexible at run time.</li>
<li>It has extensive type inference capability, such that type annotations are
not needed very often</li>
<li>It's typing discipline is structural rather than nomial, but named type aliases
are supported. This is different than most languages, but is useful for a
"scripting language"</li>
<li>It has parametric polymorphism for both lambdas and type aliases</li>
<li>It has algebreic data types</li>
<li>destructuring pattern matches are supported in select, let,
and lambda arguments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-graphix"><a class="header" href="#installing-graphix">Installing Graphix</a></h1>
<p>To install the Graphix shell from source you need to install a rust build
environment. See <a href="https://www.rust-lang.org/tools/install">here</a> for
instructions on how to do that for your platform. Once you have that set up, you
can just run</p>
<p><code>cargo install graphix-shell</code></p>
<p>That should build the <code>graphix</code> command and install it in your ~/.cargo/bin
directory. On linux you may need to install kerberos headers, as well as clang
libs for gssapi to build properly (on linux). On debian/ubuntu install
<code>libclang-dev</code>, and <code>libkrb5-dev</code>. On other distributions the names will be
similar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-language"><a class="header" href="#core-language">Core Language</a></h1>
<p>This section documents the core language constructs in Graphix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamental-types"><a class="header" href="#fundamental-types">Fundamental Types</a></h1>
<p>Graphix has a few fundamental data types, the Graphix shell is a good way to
explore them by trying out small Graphix expressions. You can run the Graphix
shell by invoking <code>graphix</code> with no arguments.</p>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p><code>i32</code>, <code>u32</code>, <code>i64</code>, <code>u64</code>, <code>f32</code>, <code>f64</code>, and <code>decimal</code> are the fundamental
numeric types in Graphix. Literals are written with their type prefixed, except
for <code>i64</code> and <code>f64</code> which are written bare. for example, <code>u32:3</code> is a <code>u32</code>
literal value.</p>
<p><code>decimal</code> is an exact decimal representation for performing financial
calculations without rounding or floating point approximation errors.</p>
<p>The basic arithmetic operations are implemented on all the number types with all
the other number types.</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Operator</th></tr></thead><tbody>
<tr><td>Add</td><td>+</td></tr>
<tr><td>Subtract</td><td>-</td></tr>
<tr><td>Multiply</td><td>*</td></tr>
<tr><td>Divide</td><td>/</td></tr>
<tr><td>Mod</td><td>%</td></tr>
</tbody></table>
</div>
<p>The compiler will let you do arithmatic on different types of numbers directly
without casting, however the return type of the operation will be the set of all
the types in the operation, representing that either type could be returned. If
you try to pass this result to a function that wants a specific numeric type, it
will fail at compile time.</p>
<pre><code>〉1. + 1
-: [i64, f64]
2
〉let f = |x: i64| x * 10
〉f(1. + 1)
error: in expr

Caused by:
    0: at: line: 1, column: 3, in: (f64:1. + i64:1)
    1: at: line: 1, column: 3, in: (f64:1. + i64:1)
    2: type mismatch '_1046: i64 does not contain [i64, f64]
</code></pre>
<p>Division by zero is raised as an error to the nearest error handler (more on
that later) and will be printed to stderr by the shell if it is never handled.
Overflow and underflow are handled by wrapping,</p>
<pre><code>〉0 / 0

thread 'tokio-runtime-worker' panicked at /home/eric/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:319:5:
attempt to divide by zero
-: i64
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
unhandled error: error:"in expr at line: 1, column: 1 attempt to divide by zero"
〉u32:0 - u32:1
-: u32
4294967295
</code></pre>
<p>It is safe to continue using the shell and runtime if such an error occurrs,
even if it is not caught. However the particular arith operation that caused the
error will not update, which may cause problems depending on what your program
is doing with it.</p>
<h3 id="number-sets"><a class="header" href="#number-sets">Number Sets</a></h3>
<p>There are a few sets of number types that classify numbers into various kinds.
<code>Number</code> being the most broad, it contains all the number types. <code>Int</code> contains
only integers, <code>Real</code> contains only reals (decimal plus the two float types),
<code>SInt</code> contains signed integers, <code>UInt</code> contains unsigned integers.</p>
<h2 id="bool"><a class="header" href="#bool">Bool</a></h2>
<p>Graphix has a boolean type, it's literals are written as <code>true</code> and <code>false</code>, and
the name of the type is <code>bool</code>.</p>
<p>Boolean expressions using <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> are supported. These operators
only operate on <code>bool</code>. They can be grouped with parenthesis. For example,</p>
<pre><code>〉true &amp;&amp; false
-: bool
false
〉true || false
-: bool
true
〉!true
-: bool
false
〉!1
error: in expr

Caused by:
    0: at: line: 1, column: 2, in: i64:1
    1: type mismatch bool does not contain i64
</code></pre>
<h2 id="duration"><a class="header" href="#duration">Duration</a></h2>
<p>A time duration. The type name is <code>duration</code>, and the literals are written as,
<code>duration:1.0s</code>, <code>duration:1.0ms</code>, <code>duration:1.0us</code>, <code>duration:1.0ns</code>. Durations
can be added, and can be multiplied and divided by scalars.</p>
<pre><code>〉duration:1.0s + duration:1.0s
-: duration
2.s
〉duration:1.0s * 50
-: duration
50.s
〉duration:1.0s / 50
-: duration
0.02s
</code></pre>
<h2 id="datetime"><a class="header" href="#datetime">DateTime</a></h2>
<p>A date and time in the UTC time zone. The type name is <code>datetime</code> and literals
are written in RFC3339 format inside quotes. For example,
<code>datetime:"2020-01-01T00:00:00Z"</code>. You can add and subtract <code>duration</code> from
<code>datetime</code>.</p>
<pre><code>〉datetime:"2020-01-01T00:00:00Z" + duration:30.s
-: datetime
2020-01-01 00:00:30 UTC
</code></pre>
<p>You can enter <code>datetime</code> literals in local time and they will be converted to UTC. For example,</p>
<pre><code>〉datetime:"2020-01-01T00:00:00-04:00"
-: datetime
2020-01-01 04:00:00 UTC
</code></pre>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>Strings in Graphix are UTF8 encoded text. The type name is <code>string</code> and the
literal is written in quotes <code>"this is a string"</code>. C style escape sequences are
supported, <code>"this is \" a string with a quote and a \n"</code>. Non printable
characters such as newline will be escaped by default when strings are printed
to the console, you can use <code>print</code> to print the raw string including control
characters.</p>
<h3 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h3>
<p>String literals can contain expressions that will be evaluated and joined to the string,
such expressions are surrounded by unescaped <code>[]</code> in the string. For example,</p>
<pre><code>〉let row = 1
〉let column = 999
〉"/foo/bar/[row]/[column]"
-: string
"/foo/bar/1/999"
</code></pre>
<p>Values in an interpolation need not be strings, they will be cast to a string
when they are used. You can write a literal <code>[</code> or <code>]</code> in a string by escaping
it.</p>
<pre><code>〉"this is a string with a \[ and a \] but it isn't an interpolation"
-: string
"this is a string with a [ and a ] but it isn't an interpolation"
</code></pre>
<h2 id="any"><a class="header" href="#any">Any</a></h2>
<p>The <code>Any</code> type is a type that unifies with any other type, it corresponds to the
underlying variant type that represents all values in Graphix (and netidx). It
is not used very often, as it provides very few guarantees, however it has it's
place. For example, <code>Any</code> is the type returned by <code>net::subscribe</code>, indicating
that any valid netidx value can come from the network. Usually the first thing
you do with an <code>Any</code> type is call <code>cast</code> to turn it into the type you expect (or
an error), or use a <code>select</code> expression to match it's type (more on select later).</p>
<h2 id="null"><a class="header" href="#null">Null</a></h2>
<p>Null is nothing, just like in many other languages. Unlike most other languages
<code>null</code> is a type not a catch all hack. If the type of a value does not include
<code>null</code> then it can't be null. The set <code>['a, null]</code> is commonly used instead of
an option type in Graphix, it serves the same purpose, and is more efficient,
because <code>null</code> is part of the underlying variant that represents all Graphix
values after type erasure.</p>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>Arrays in Graphix have a type parameter indicating their element type.
<code>Array&lt;string&gt;</code> indicates an array of strings. Every element of an array must be
the same type. Arrays are zero indexed <code>a[0]</code> is the first element. Arrays can
hold any Graphix type as an element, including other arrays at arbitrary levels
of nesting. There is a special type <code>Array&lt;Any&gt;</code> that can also be written as
<code>array</code> (case sensitive), that represents the fundamental array type in the
underlying value representation. <code>[x, y, z]</code> constructs a three element array.
There are many functions in the <code>array</code> module of the standard library for
working with arrays.</p>
<h3 id="array-slicing-and-indexing"><a class="header" href="#array-slicing-and-indexing">Array Slicing and Indexing</a></h3>
<p>Graphix supports array subslicing, the syntax will be familar to Rust programmers.</p>
<ul>
<li><code>a[2..]</code> a slice from index 2 to the end of the array</li>
<li><code>a[..4]</code> a slice from the beginning of the array to index 3</li>
<li><code>a[1..3]</code> a slice from index 1 to index 2</li>
<li><code>a[-1]</code> the last element in the array</li>
<li><code>a[-2]</code> the second to last element in the array</li>
</ul>
<p><code>..=</code> is not supported however, the second part of the slice will always be the
exclusive bound. Literal numbers can always be replaced with a Graphix
expression, e.g. <code>a[i..j]</code> is perfectly valid.</p>
<h3 id="mutability-and-implementation"><a class="header" href="#mutability-and-implementation">Mutability and Implementation</a></h3>
<p>Arrays are not mutable, like all other Graphix values. All operations that
"change" an array, actually create a new array leaving the old one unchanged.
This is even true of the connect operator, which we will talk more about later.</p>
<p>There are a couple of important notes to understand about the implementation of
Arrays.</p>
<ul>
<li>
<p>Arrays are memory pooled, in almost all cases (besides really huge arrays)
creating an array does not actually allocate any memory, it just reuses a
previously used array that has since become unused. This makes using arrays a
lot more efficient than you might expect.</p>
</li>
<li>
<p>Arrays are contiguous in memory, there is no funny business going on (looking
at you lua). This means they are generally very memory efficient, each element
is 3 machine words, and fast to access. However there are a few cases where
this causes a problem, such as building up an array by appending one element
at a time. This is sadly an O(N^2) operation on arrays. You may wish to use
another data structure for this kind of operation.</p>
</li>
<li>
<p>Array slices are zero copy. They do not allocate memory, and they do not clone
any of the array's elements, they simply create a light weight view into the
array. This means algorithms that progressively deconstruct an array by
slicing are O(N) not O(N^2) and the constants are very fast.</p>
</li>
</ul>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Tuples are written <code>(x, y)</code>, they can be of arbitrary length, and each element
may have a different type. Tuples may be indexed using numeric field indexes.
Consider</p>
<pre><code>let x = (1, 2, 3, 4);
x.0
</code></pre>
<p>Will print 1.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-binds"><a class="header" href="#let-binds">Let Binds</a></h1>
<p>Let bindings introduce names that are visible in their scope after they are
defined.</p>
<pre><code>let x = 2 + 2 + x; // error x isn't defined yet
let y = x + 1 // ok
</code></pre>
<p>The same name can be used again in the same scope, it will shadow the previous
value.</p>
<pre><code>let x = 1;
let x = x + 1; // ok uses the previous definition
x == 2 // true
</code></pre>
<p>You can annotate the binding with a type, which will then be enforced at compile
time. Sometimes this is necessary in order to help type inference.</p>
<pre><code>let x: Number = 1; // note x will be of type Number even though it's an i64
let y: string = x + 1; // compile time type error
</code></pre>
<p>You can use destructuring patterns in let binds as long as they will always
match.</p>
<pre><code>let (x, y) = (3, "hello"); // binds x to 3 and y to "hello"
x == 3; // true
y == "hello" // true
</code></pre>
<p>You can mix type annotations with pattern matches</p>
<pre><code>let (x, y): (i64, string) = (3, "hello")
</code></pre>
<p>You can assign documentation to a let bind using a <code>///</code> comment. Documentation
will be displayed in the shell when the user tab completes and will be made
available by the lsp server (when one exists).</p>
<pre><code>// this is a normal comment
let x = 1;
/// this is documentation for y
let y = 2;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect"><a class="header" href="#connect">Connect</a></h1>
<p>Connect, written <code>x &lt;- expr</code> is where things get interesting in Graphix. The
sharp eyed may have noticed that up until now there was no way to introduce a
cycle in the graph. Connect is the first (and really the only) graph operator in
Graphix, it allows you to connect one part of the graph to another by name,
causing the output of the right side to flow to the name on the left side.
Consider,</p>
<pre><code>let x = "off"
x &lt;- time::timer(duration:1.0s, false) ~ "on"
print(x)
</code></pre>
<p>This program will first print <code>off</code>, and after 1 second it will print <code>on</code>. Note
the <code>~</code> operator means, when the expression on the left updates return the
current value of the expression on the right (called the sample operator). The
graph we created looks like,</p>
<pre><code>const("off") ===============&gt; "x" =======&gt; print
                              ^
                              |
time::timer ====&gt; sample =====
                 ^
                 |
const("on") =====
</code></pre>
<p>We can also build an infinite loop with connect. This won't crash the program,
and it won't stop other parts of the program from being evaluated, it's a
completely legit thing to do.</p>
<pre><code>let x = 0;
x &lt;- x + 1;
print(x)
</code></pre>
<p>This program will print all the i64s from 0 to MAX and then will wrap around. It
will print numbers forever. You might notice, and you might wonder, why does it
start from zero, shouldn't it start from 1? After all we increment x BEFORE the
print right? Well, no, not actually, it will start at 0, for the same reason
this infinite loop won't lock up the program or cause other expressions not to
be evaluated. Graphix programs are evaluated in cycles, a batch of updates from
the network, timers, and other IO is processed into a set of all events that
happened "now", then the parts of the program that care about those particular
events are evaluated, and then the main loop goes back to waiting for events.</p>
<p>What connect does is it schedules an update to <code>x</code> for the next cycle, the
current cycle proceeds as normal to it's conclusion as if the connect didn't
happen yet, because it didn't. In the above case the event loop would never
wait, because there is always work to do adding 1 to <code>x</code>, however it will still
check for IO events, and any other events that might have happened.</p>
<p>When combined with other operations, specifically select, connect becomes a
powerful general looping construct, and is actually the only way to write a loop
in Graphix. A quick example,</p>
<pre><code>let count = {
  let x = 0;
  select x {
    n if n &lt; 10 =&gt; x &lt;- x + 1,
    _ =&gt; never()
  };
  x
};
count
</code></pre>
<p>This program creates a bind <code>count</code> that will update with the values 0 to 10. If
you put it in a file <code>test.gx</code> and execute it using <code>graphix ./test.gx</code> it will
print 0 to 10 and then wait.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
0
1
2
3
4
5
6
7
8
9
10
</code></pre>
<h3 id="is-connect-mutation"><a class="header" href="#is-connect-mutation">Is Connect Mutation?</a></h3>
<p>Connect causes let bound names to update, so it's kind of mutation. Kind of. A
better way to think about it is that every let bound value is a pipe with
multiple producers and multiple consumers. Connect adds a new producer to the
pipe. The values being produced are immutable, an array <code>[1, 2, 3]</code> will always
and forever be <code>[1, 2, 3]</code>, but a new array <code>[1, 2, 3, 4]</code> might be pushed into
the same pipe <code>[1, 2, 3]</code> came from, and that might make it appear that the
array changed. The difference is, if you captured the original <code>[1, 2, 3]</code> and
put it somewhere, a new <code>[1, 2, 3, 4]</code> arriving on the pipe can't change the
original array.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks"><a class="header" href="#blocks">Blocks</a></h1>
<p>A block is a group of code between <code>{</code> and <code>}</code> that has it's own scope, and
evaluates to the last value in the block. Expressions in a block are <code>;</code>
separated, meaning every expression except the last one must end in a <code>;</code> and
it is illegal for a block to have just one expression (it will not parse).</p>
<p>You can use blocks to hide intermediate variables from outer scopes, and to
group code together in a logical way.</p>
<pre><code>let important_thing = {
  let x = 0;
  let y = x + 1;
  43 - y
};

x; // compile error, x isn't in scope
y; // compile error, y isn't in scope
important_thing
</code></pre>
<p>This program won't compile because you can't reference y and x from outside the
block scope, but if you removed those refernces it would print a very important
number. Blocks are valid anywhere an expression is valid, and they are just
expressions. They will become very important when we introduce lambda
expressions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use"><a class="header" href="#use">Use</a></h1>
<p>Use allows you to bring names in modules into your current scope so they can be used without prefixing.</p>
<pre><code>net::subscribe(...); // call subscribe in the net module
use net;
subscribe(...) // same function
</code></pre>
<p>Use is valid anywhere expressions are valid</p>
<pre><code>let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
list
</code></pre>
<p>will print <code>[2, 4, 6, 8, 10]</code></p>
<pre><code>let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
map(list, |x| x * 2)
</code></pre>
<p>will not compile, e.g.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    at line: 5, column: 1 map not defined
</code></pre>
<p>Use shadows earlier declarations in it's scope. Consider,</p>
<pre><code>let map = |a, f| "hello you called map!";
let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
(list, map(list, |x| x * 2))
</code></pre>
<p>prints</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
([2, 4, 6, 8, 10], "hello you called map!")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<p>Select lets us create a graph node with multiple possible output paths that
will choose one path for each value based on a set of conditions. Kind of like,</p>
<pre><code>                   | if foo &gt; 0 =&gt;  ...
                   |
                   |
ref(foo) =&gt; select | if foo &lt; 0 =&gt; ...
                   |
                   |
                   | otherwise =&gt; ...
</code></pre>
<p>is written as</p>
<pre><code>select foo {
  n if n &gt; 0 =&gt; ...,
  n if n &lt; 0 =&gt; ...,
  n =&gt; ...
}
</code></pre>
<p>select takes an expression as an argument and then evaluates one or more "arms".
Each arm consists of an optional type predicate, a destructuring pattern, and an
optional guard clause. If the type predicate matches, the pattern matches, and
the guard evaluates to true then the arm is "selected". Only one arm may be
selected at a time, the arms are evaluated in lexical order, and first arm to be
selected is chosen as the one and only selected arm.</p>
<p>The code on the right side of the selected arm is the only code that is
evaluated by select, all other code is "asleep", it will not be evaluated
until it is selected (and if it has netidx subscriptions or published values
they will be unsubscribed and unpublished until it is selected again).</p>
<h2 id="matching-types"><a class="header" href="#matching-types">Matching Types</a></h2>
<p>Consider we want to select from a value of type <code>[Array&lt;i64&gt;, i64, null]</code>,</p>
<pre><code>let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n =&gt; n,
  null as _ =&gt; 42
}
</code></pre>
<p>This program will print 42, 15, 7 and then wait. The compiler will check that
you have handled all the possible cases. If we remove the null case from this
select we will get a compile error.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    missing match cases type mismatch [i64, Array&lt;i64&gt;] does not contain [[i64, null], Array&lt;i64&gt;]
</code></pre>
<p>If you read this carefully you can see that the compiler is building up a set of
types that we did match, and checking that it contains the argument type. This
goes both ways, a match case that could never match is also an error.</p>
<pre><code>let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n =&gt; n,
  f64 as n =&gt; cast&lt;i64&gt;(n)?,
  null as _ =&gt; 42
}
</code></pre>
<p>Here we've added an <code>f64</code> match case, but the argument type can never contain an
<code>f64</code> so we will get a compile error.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    pattern f64 will never match null, unused match cases
</code></pre>
<p>The diagnostic message gives you an insight into the compiler's thinking. What
it is saying is that, by the time it's gotten to looking at the <code>f64</code> pattern,
the only type left in the argument that hasn't already been matched is <code>null</code>,
and since <code>f64</code> doesn't unify with <code>null</code> it is sure this pattern can never
match.</p>
<p>Guarded patterns can always not match because of the guard, so they do not
subtract from the argument type set. You are required to match without a guard
at some point. No analysis is done to determine if your guard covers the entire
range of a type.</p>
<pre><code>let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n if n &gt; 10 =&gt; n,
  null as _ =&gt; 42
}
</code></pre>
<p>This will fail with a missing match case because the <code>i64</code> pattern is guarded
and no unguarded pattern exists that matches <code>i64</code>.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    missing match cases type mismatch [null, Array&lt;i64&gt;] does not contain [[i64, null], Array&lt;i64&gt;]
</code></pre>
<p>This is the same error you would get if you omitted the <code>i64</code> match case
entirely.</p>
<h2 id="matching-structure"><a class="header" href="#matching-structure">Matching Structure</a></h2>
<p>The type predicate is optional in a pattern, and the more commonly used pattern
is structural. Graphix supports several kinds of structural matching,</p>
<ul>
<li>array slices</li>
<li>tuples</li>
<li>structs</li>
<li>variants</li>
<li>literals, ignore</li>
</ul>
<h3 id="slice-patterns"><a class="header" href="#slice-patterns">Slice Patterns</a></h3>
<p>Suppose we want to classify arrays that have at least two elements vs arrays
that don't, and we want to return a variant with a triple of the first two
elements and the rest of the array or `Short with the whole array.</p>
<pre><code>let a = [1, 2, 3, 4];
a &lt;- [1];
a &lt;- [5, 6];
select a {
  [x, y, tl..] =&gt; `Ok((x, y, tl)),
  a =&gt; `Short(a)
}
</code></pre>
<p>This program will print,</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
`Ok((1, 2, [3, 4]))
`Short([1])
`Ok((5, 6, []))
</code></pre>
<p>The following kinds of slice patterns are supported,</p>
<ul>
<li>
<p>whole slice, with binds, or literals, e.g. <code>[1, x, 2, y]</code> matches a 4 element
array and binds it's 2nd and 4th element to <code>x</code> and <code>y</code> respectivly.</p>
</li>
<li>
<p>head pattern, like the above program, e.g. <code>[(x, y), ..]</code> matches the first
pair in an array of pairs and ignores the rest of the array, binding the pair
elements to <code>x</code> and <code>y</code>. You can also name the remainder, as we saw, e.g.
<code>[(x, y), tl..]</code> does the same thing, but binds the rest of the array to <code>tl</code></p>
</li>
<li>
<p>tail pattern, just like the head pattern, but for the end of the array. e.g.
<code>[hd.., {foo, bar}]</code> matches the last element of an array of structs with
fields <code>foo</code> and <code>bar</code>, binding <code>hd</code> to the array minus the last element, and
<code>foo</code> to field foo and <code>bar</code> to field bar.</p>
</li>
</ul>
<p>Structure patterns (all of the differnt types) can be nested to any depth.</p>
<h3 id="tuple-patterns"><a class="header" href="#tuple-patterns">Tuple Patterns</a></h3>
<p>Tuple patterns allow you to match tuples. Compared to slice patterns they are
fairly simple. You must specify every field of the tuple, you can choose to bind
it, or ignore it with <code>_</code>. e.g.</p>
<p><code>("I", "am", "a", "happy", "tuple", w, _, "patterns")</code></p>
<h3 id="struct-patterns"><a class="header" href="#struct-patterns">Struct Patterns</a></h3>
<p>Struct patterns, like tuple patterns, are pretty simple.</p>
<ul>
<li><code>{ x, y }</code> if you like the field names then there is no need to change them</li>
<li><code>{ x: x_coord, y: y_coord }</code> but if you need to use a different name you can</li>
<li><code>{ x, .. }</code> you don't have to write every field</li>
</ul>
<p>Consider</p>
<pre><code>let a = {x: 54, y: 23};
a &lt;- {x: 21, y: 88};
a &lt;- {x: 5, y: 42};
a &lt;- {x: 23, y: 32};
select a {
  {x, y: _} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall,
  {y, x: _} if (y &lt; 10) || (y &gt; 40)  =&gt; `HWall,
  {x, y} =&gt; `Ok(x, y)
}
</code></pre>
<p>does some 2d bounds checking, and will output</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
`VWall
`HWall
`VWall
`Ok(23, 32)
</code></pre>
<p>You might be tempted to replace <code>y: _</code> with <code>..</code> as it would be shorter.
Unfortunatly this will confuse the type checker, because the Graphix type system
is structural saying <code>{x, ..}</code> without any other information could match ANY
struct with a field called <code>x</code>. This is currently too much for the type checker
to handle,</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    pattern {x: '_1040} will never match {x: i64, y: i64}, unused match cases
</code></pre>
<p>The error is slightly confusing at first, until you understand that since we
don't know the type of <code>{x, ..}</code> we don't think it will match the argument type,
and therefore the match case is unused. This actually saves us a lot of trouble
here, because the last match is exhaustive, if we didn't check for unused match
cases this program would compile, but it wouldn't work. You can easily fix this
by naming the type, and for larger structs it's often worth it if you only need
a few fields.</p>
<pre><code>type T = {x: i64, y: i64};
let a = {x: 54, y: 23};
a &lt;- {x: 21, y: 88};
a &lt;- {x: 5, y: 42};
a &lt;- {x: 23, y: 32};
select a {
  T as {x, ..} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall,
  T as {y, ..} if (y &lt; 10) || (y &gt; 40)  =&gt; `HWall,
  {x, y} =&gt; `Ok(x, y)
}
</code></pre>
<p>Here since we've included the type pattern <code>T</code> in our partial patterns the
program compiles and runs.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
`VWall
`HWall
`VWall
`Ok(23, 32)
</code></pre>
<p>Note that we never told the compiler that <code>a</code> is of
type <code>T</code>. In fact <code>T</code> is just an alias for <code>{x: i64, y: i64}</code> which is the type
of <code>a</code>. We could in fact write our patterns without the alias,</p>
<p><code>{x: i64, y: i64} as {x, ..} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall</code></p>
<p>The type alias just makes the code less verbose without changing the semantics.</p>
<h3 id="variant-patterns"><a class="header" href="#variant-patterns">Variant Patterns</a></h3>
<p>Variant patterns match variants. Consider,</p>
<pre><code>let v: [`Bare, `Arg(i64), `MoreArg(string, i64)] = `Bare;
v &lt;- `Arg(42);
v &lt;- `MoreArg("hello world", 42);
select v {
  `Bare =&gt; "it's bare, no argument",
  `Arg(i) =&gt; "it has an arg [i]",
  x@ `MoreArg(s, n) =&gt; "it's big [x] with args \"[s]\" and [n]"
}
</code></pre>
<p>produces</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
"it's bare, no argument"
"it has an arg 42"
"it's big `MoreArg(\"hello world\", 42) with args \"hello world\" and 42"
</code></pre>
<p>Variant patterns enforce the same kinds of match case checking as all the other pattern types</p>
<pre><code>let v: [`Bare, `Arg(i64), `MoreArg(string, i64)] = `Bare;
v &lt;- `Arg(42);
v &lt;- `MoreArg("hello world", 42);
select v {
  `Bare =&gt; "it's bare, no argument",
  `Arg(i) =&gt; "it has an arg [i]",
  x@ `MoreArg(s, n) =&gt; "it's big [x] with args \"[s]\" and [n]",
  `Wrong =&gt; "this won't compile"
}
</code></pre>
<p>yields</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    pattern `Wrong will never match [`Arg(i64), `MoreArg(string, i64)], unused match cases
</code></pre>
<h3 id="literals-ignore"><a class="header" href="#literals-ignore">Literals, Ignore</a></h3>
<p>You can match literals as well as bind variables, as you may have noticed, and
the special pattern <code>_</code> means match anything and don't bind it to a variable.</p>
<h3 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h3>
<p>A significant missing feature from patterns vs other languages is support for
multiple alternative patterns in one arm. I plan to add this at some point.</p>
<h2 id="select-and-connect"><a class="header" href="#select-and-connect">Select and Connect</a></h2>
<p>Using select and connect together is one way to iterate in Graphix. Consider,</p>
<pre><code>let a = [1, 2, 3, 4, 5];
let len = 0;
select a {
  [x, tl..] =&gt; {
    len &lt;- len + 1;
    a &lt;- tl
  },
  _ =&gt; len
}
</code></pre>
<p>produces</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
5
</code></pre>
<p>This is not normally how we would get the length of an array in Graphix, or even
how we would do something with every element of an array (see <code>array::map</code> and
<code>array::fold</code>), however it illustrates the power of select and connect together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are first class values. They can be stored in variables, in data
structures, and they can be passed around to other functions. Etc. They are
defined with the syntax,</p>
<pre><code>|arg0, arg1, ...| body
</code></pre>
<p>This is often combined with a let bind to make a named function.</p>
<pre><code>let f = |x, y| x + y + 1
</code></pre>
<p><code>f</code> is now bound to the lambda that adds it's two arguments and 1. You can also
use structure patterns in function arguments as long as the pattern will always
match.</p>
<pre><code>let g =|(x, y), z| x + y + z
</code></pre>
<p>Type annotations can be used to constrain the argument types and the return
type,</p>
<pre><code>let g = |(x, y): (f64, f64), z: f64| -&gt; f64 x + y + z
</code></pre>
<p>Functions are called with the following syntax.</p>
<pre><code>f(1, 1)
</code></pre>
<p>Would return 3. If the function is stored in a data structure, then sometimes
you need parenthesis to call it.</p>
<pre><code>(s.f)(1, 1)
</code></pre>
<p>Would call the function <code>f</code> in the struct <code>s</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="labeled-and-optional-arguments"><a class="header" href="#labeled-and-optional-arguments">Labeled and Optional Arguments</a></h1>
<p>Functions can have labeled and also optional arguments. Labeled arguments need
not be specified in order, and optional arguments don't need to be specified at
all. When declaring a function you must specify the labeled and optional
arguments before any non labeled arguments.</p>
<pre><code>let f = |#lbl1, #lbl2, arg| ...
</code></pre>
<p>In this case lbl1 and 2 are not optional, but are labeled. You can call f with
either labeled argument in either order. e.g. <code>f(#lbl2, #lbl1, a)</code>.</p>
<pre><code>let f = |#opt = null, a| ...
</code></pre>
<p><code>opt</code> need not be specifed when <code>f</code> is called, if it isn't specified then it
will be <code>null</code>. e.g. <code>f(2)</code> is a valid way to call <code>f</code>. You can also apply type
constraints to labeled and optional arguments.</p>
<pre><code>let f = |#opt: [i64, null] = null, a| ..
</code></pre>
<p>Specifies that <code>opt</code> can be either an <code>i64</code> or <code>null</code> and by default it is null.
The compiler implements subtyping for functions with optional arguments. For
example if you write a function that takes a function with a labeled argument
<code>foo</code>, you can pass any function that has a labeled argument <code>foo</code>, even if it
also has other optional arguments. The non optional and non labeled arguments
must match, of course. For example,</p>
<pre><code>let f = |g: fn(#foo:i64, i64) -&gt; i64, x: i64| g(#foo:x, x);
let g = |#foo:i64, #bar: i64 = 0, x: i64| foo + bar + x;
f(g, 42) // valid call
</code></pre>
<p>outputs</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
84
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures-and-first-class-functions"><a class="header" href="#closures-and-first-class-functions">Closures and First Class Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="detailed-semantics"><a class="header" href="#detailed-semantics">Detailed Semantics</a></h1>
<p>Considering the underlying execution model functions might be better described
as "polymorphic graph templates", in that they allow you to specify a part of
the graph once, and then use it multiple times with different types each time.
Most of the time this difference in semantics doesn't matter. Most of the time.
Consider,</p>
<pre><code>let n = cast&lt;i64&gt;(net::subscribe("/hev/stats/power")?)?;
f(n, 1)
</code></pre>
<p>What happens here? Does <code>f</code> get "called" every time <code>n</code> updates? Does it only
work for the first <code>n</code>? Does it explode? Lets transform it like the compiler
would in order to understand it better,</p>
<pre><code>let n = cast&lt;i64&gt;(net::subscribe("/hev/stats/power")?)?;
n + 1 + 1
</code></pre>
<p>The "arguments" to the function call were plugged into the holes in the graph
template and then the whole template is copied to the call site, and from then
on the graph runs as normal.</p>
<p>Lets revisit an earlier example where we used select and connect to find the
length of an array. Suppose we want to generalize that into a function,</p>
<pre><code>let len = |a: Array&lt;'a&gt;| {
  let sum = 0;
  select a {
    [x, tl..] =&gt; {
      sum &lt;- sum + 1;
      a &lt;- tl
    },
    _ =&gt; sum
  }
}
</code></pre>
<p>Lets just ignore the <code>'a</code> for now. Here we have a function that takes an array
with any element type and returns it's length. Brilliant, lets call it,</p>
<pre><code>let a = [1, 2, 3, 4, 5];
len(a)
</code></pre>
<p>and when we run this we get,</p>
<pre><code>eric@katana ~ [1]&gt; proj/graphix/target/debug/graphix ./test.gx
5
</code></pre>
<p>That's the right answer. Are we done? Noooooooo. No we are not done. Lets see
what happens if we do,</p>
<pre><code>let a = [1, 2, 3, 4, 5];
a &lt;- [1, 2, 3];
a &lt;- [1, 2];
len(a)
</code></pre>
<p>this results in,</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
4
</code></pre>
<p>What!? That's not even wrong. That's just nonsense, what happened? The key to
understanding this problem is that there is just one call site, which means we
instantiated this little reusable bit of graph one time, just one time. That
means there is just one <code>sum</code>, one <code>a</code>, basically just one graph. When we use
connect to iterate we are using graph traversal cycles to do a new element of
the array every cycle until we are done. It will take 5 cycles for the first
array to be done, and that's the problem, because we update <code>a</code> with a whole new
array in cycle 1 and again in cycle 2. That's why we get 4, it's determanistic,
we will get 4 every time.</p>
<ul>
<li>the first cycle we add 1 to <code>sum</code> and set the inner <code>a</code> to <code>tl</code> (it's not the
same variable as the outer <code>a</code>, which is why the chaos isn't even greater). But
the outer <code>a</code> also gets set to <code>[1, 2, 3]</code> and that overwrites the inner set
because it happens after it (because that's just the way the runtime works).</li>
<li>the second cycle we add 1 to <code>sum</code> and set the inner <code>a</code> to <code>[2, 3]</code> and the
outer <code>a</code> to <code>[1, 2]</code></li>
<li>the third cycle we add 1 to <code>sum</code> and set the inner <code>a</code> to <code>[2]</code></li>
<li>the 4th cycle we add 1 to <code>sum</code> and set <code>a</code> to <code>[]</code></li>
<li>the 5th cycle we update our return value with <code>sum</code>, which is now 4</li>
</ul>
<p>We can only fix this be understanding that we're programming a graph. I tried to
make Graphix as much like a normal language as possible, but this is where we
depart from that possibility. The general idea is, we need to queue updates to
the outer <code>a</code> until we're done processing the current one. For that we have a
builtin called <code>queue</code>, here is the correct implementation</p>
<pre><code>let len = |a: Array&lt;'a&gt;| {
  let clock = once(null);
  let q = queue(#clock, a);
  let sum = 0;
  select q {
    [x, tl..] =&gt; {
      sum &lt;- sum + 1;
      q &lt;- tl
    },
    _ =&gt; {
      clock &lt;- null;
      sum &lt;- 0;
      once(sum)
    }
  }
}
</code></pre>
<p>Every time <code>clock</code> updates <code>queue</code> will output something it has queued, or if it
has nothing queued it will store that the next thing that arrives can go out
immediatly. So the first <code>a</code> will immediatly pass through the queue, but
anything after that will be held. Then the normal select loop will run, except
it will look at <code>q</code> instead of <code>a</code> now, so that <code>a</code> can update without
disturbing it. When we get to the terminating case, we update for next cycle
<code>clock</code> with <code>null</code> and <code>sum</code> with 0 and we return <code>once(sum)</code>. We return
<code>once(sum)</code> instead of just <code>sum</code> because removing something from the queue
takes one cycle, so it will be two cycles before we start on the next array, and
in the mean time the existing array will still be empty, meaning the second
select arm will still be selected, and <code>sum</code> is updating to 0 which we do not
want to return. If we run this with the same set of examples we will get the
correct answer,</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./cycle_iter.gx
5
3
2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-defined-types"><a class="header" href="#user-defined-types">User Defined Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variants"><a class="header" href="#variants">Variants</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples-1"><a class="header" href="#tuples-1">Tuples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="named-types"><a class="header" href="#named-types">Named Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parametric-polymorphism"><a class="header" href="#parametric-polymorphism">Parametric Polymorphism</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-modules"><a class="header" href="#inline-modules">Inline Modules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-modules"><a class="header" href="#external-modules">External Modules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-modules"><a class="header" href="#dynamic-modules">Dynamic Modules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-standard-library"><a class="header" href="#the-standard-library">The Standard Library</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core"><a class="header" href="#core">core</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net"><a class="header" href="#net">net</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-1"><a class="header" href="#array-1">array</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="str"><a class="header" href="#str">str</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="re"><a class="header" href="#re">re</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time"><a class="header" href="#time">time</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rand"><a class="header" href="#rand">rand</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-uis-with-graphix"><a class="header" href="#building-uis-with-graphix">Building UIs With Graphix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuis"><a class="header" href="#tuis">TUIs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="barchart"><a class="header" href="#barchart">barchart</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block"><a class="header" href="#block">block</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="browser"><a class="header" href="#browser">browser</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calendar"><a class="header" href="#calendar">calendar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas"><a class="header" href="#canvas">canvas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chart"><a class="header" href="#chart">chart</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">text</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paragraph"><a class="header" href="#paragraph">paragraph</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gauge"><a class="header" href="#gauge">gauge</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linegauge"><a class="header" href="#linegauge">linegauge</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">layout</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list"><a class="header" href="#list">list</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll"><a class="header" href="#scroll">scroll</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparkline"><a class="header" href="#sparkline">sparkline</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table"><a class="header" href="#table">table</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tabs"><a class="header" href="#tabs">tabs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-graphix"><a class="header" href="#embedding-graphix">Embedding Graphix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-built-in-functions"><a class="header" href="#writing-built-in-functions">Writing Built in Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-graphix-shell"><a class="header" href="#using-graphix-shell">Using graphix-shell</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-graphix-rt"><a class="header" href="#using-graphix-rt">Using graphix-rt</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
