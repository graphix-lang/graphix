<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Graphix Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Graphix Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="installing-graphix"><a class="header" href="#installing-graphix">Installing Graphix</a></h1>
<p>To install the Graphix shell from source you need to install a rust build
environment. See <a href="https://www.rust-lang.org/tools/install">here</a> for
instructions on how to do that for your platform. Once you have that set up, you
can just run</p>
<p><code>cargo install graphix-shell</code></p>
<p>That should build the <code>graphix</code> command and install it in your ~/.cargo/bin
directory. On linux you may need to install kerberos headers, as well as clang
libs for gssapi to build properly (on linux). On debian/ubuntu install
<code>libclang-dev</code>, and <code>libkrb5-dev</code>. On other distributions the names will be
similar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro-to-graphix"><a class="header" href="#intro-to-graphix">Intro to Graphix</a></h1>
<p>The first goal of Graphix is to make it easy to build user interfaces to
display, interact with, and control resources published in
<a href="https://netidx.github.io/netidx-book">netidx</a>. As such graphix is a "reactive"
or dataflow language. Instead of compiling to machine code, or bytecode like
other languages graphix programs compile to a directed graph. Operations like +
are graph nodes, and edges represent paths between nodes that data can take.
Running the program means starting the flow of data into the graph so that it
will flow through, and be transformed by, the nodes of the graph. Consider,</p>
<pre><code>let x = cast&lt;i64&gt;(net::subscribe("/foo")?)?;
print(x * 10)
</code></pre>
<p>net::subscribe, subscribes to a netidx path and returns it's value, or an error
(more on ? later). If you read this like a "normal" functional or imperative
program, it appears to get the current value of "/foo", multiply it by 10 and
print the result, no other explanation really makes sense. However in the dataflow paradigm, this compiles to a graph,</p>
<pre><code>                                   const(10) ==
                                                |
                                                |
                                                v
const("/foo") =&gt; net::subscribe =&gt; cast&lt;i64&gt; =&gt; * =&gt; print
</code></pre>
<p>net::subscribe's value will change when the value in netidx changes, and that
new value will flow through the graph and be transformed by all the nodes it
passes through. So in graphix, this program will print the current value of
"/foo" in netix multiplied by 10, and when that value changes it will print an
updated value.</p>
<p>This is a powerful way to think about programming, and it's especially well
suited to building user interfaces and transforming data streams, as we will see
in this book.</p>
<p>In all other respects Graphix aims to be a normal language that would feel
familair to anyone who knows OCaml, Rust, Haskell, or another similar modern
language.</p>
<ul>
<li>It is lexically scoped</li>
<li>It is expression oriented, every language construct is an expression that
results in a value</li>
<li>It is strongly statically typed, using type erasure on top of a flexible
universal variant type. Making it both good at catching errors at compile
time, and flexible at run time.</li>
<li>It has extensive type inference capability, such that type annotations are
not needed very often</li>
<li>It's typing discipline is structural rather than nomial, but named type aliases
are supported. This is different than most languages, but is useful for a
"scripting language"</li>
<li>It has parametric polymorphism for both lambdas and type aliases</li>
<li>It has algebreic data types</li>
<li>destructuring pattern matches are supported in select, let,
and lambda arguments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-language"><a class="header" href="#core-language">Core Language</a></h1>
<p>This section documents the core language constructs in Graphix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamental-types"><a class="header" href="#fundamental-types">Fundamental Types</a></h1>
<p>Graphix has a few fundamental data types, the Graphix shell is a good way to
explore them by trying out small Graphix expressions. You can run the Graphix
shell by invoking <code>graphix</code> with no arguments.</p>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p><code>i32</code>, <code>u32</code>, <code>i64</code>, <code>u64</code>, <code>f32</code>, <code>f64</code>, and <code>decimal</code> are the fundamental
numeric types in Graphix. Numbers are written with their type prefixed, except
for <code>i64</code> and <code>f64</code> which are written bare (and are thus the default numeric
types). for example, <code>u32:3</code> is a <code>u32</code> literal value.</p>
<p><code>decimal</code> is an exact decimal representation for performing financial
calculations without rounding or floating point approximation errors.</p>
<p>The basic arithmetic operations are implemented on all the number types with all
the other number types. The type system allows you to control the outcomes. For
example,</p>
<pre><code>〉1. + 1
-: [i64, f64]
2
</code></pre>
<p>The compiler will let you do arithmatic on different types of numbers directly
without casting, however the return type of the operation will be the set of all
the types in the operation, representing that either type could be returned. If
you try to pass this result to a function that wants a specific numeric type, it
will fail at compile time.</p>
<pre><code>〉1.2321 + 1
-: [i64, f64]
2.2321
</code></pre>
<p>In the first case we actually got an <code>i64:2</code> back from the addition, but in this
case we get an <code>f64:2.2321</code> because we can't represent the fractional part of
the <code>f64</code> in an <code>i64</code>. In general when operating on numbers of different types
you may get any type in the set back, you shouldn't rely on more precise
behavior than that.</p>
<p>Division by zero is raised as an error to the nearest error handler (more on
that later) and will be printed to stderr by the shell if it is never handled.
Overflow and underflow are handled by wrapping,</p>
<pre><code>〉0 / 0

thread 'tokio-runtime-worker' panicked at /home/eric/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:319:5:
attempt to divide by zero
-: i64
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
unhandled error: error:"in expr at line: 1, column: 1 attempt to divide by zero"
〉u32:0 - u32:1
-: u32
4294967295
</code></pre>
<p>It is safe to continue using the shell and runtime if such an error occurrs,
even if it is not caught. However the particular arith operation that caused the
error will not update, which may cause problems depending on what your program
is doing with it.</p>
<h3 id="number-sets"><a class="header" href="#number-sets">Number Sets</a></h3>
<p>There are a few sets of number types that classify numbers into various kinds.
<code>Number</code> being the most broad, it contains all the number types. <code>Int</code> contains
only integers, <code>Real</code> contains only reals (decimal plus the two float types),
<code>SInt</code> contains signed integers, <code>UInt</code> contains unsigned integers.</p>
<h2 id="bool"><a class="header" href="#bool">Bool</a></h2>
<p>Graphix has a boolean type, it's literals are written as <code>true</code> and <code>false</code>, and
the name of the type is <code>bool</code>.</p>
<p>Boolean expressions using <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> are supported. These operators
only operate on <code>bool</code>. They can be grouped with parenthesis. For example,</p>
<pre><code>〉true &amp;&amp; false
-: bool
false
〉true || false
-: bool
true
〉!true
-: bool
false
〉!1
error: in expr

Caused by:
    0: at: line: 1, column: 2, in: i64:1
    1: type mismatch bool does not contain i64
</code></pre>
<h2 id="duration"><a class="header" href="#duration">Duration</a></h2>
<p>A time duration. The type name is <code>duration</code>, and the literals are written as,
<code>duration:1.0s</code>, <code>duration:1.0ms</code>, <code>duration:1.0us</code>, <code>duration:1.0ns</code>. Durations
can be added, and can be multiplied and divided by scalars.</p>
<pre><code>〉duration:1.0s + duration:1.0s
-: duration
2.s
〉duration:1.0s * 50
-: duration
50.s
〉duration:1.0s / 50
-: duration
0.02s
</code></pre>
<h2 id="datetime"><a class="header" href="#datetime">DateTime</a></h2>
<p>A date and time in the UTC time zone. The type name is <code>datetime</code> and literals
are written in RFC3339 format inside quotes. For example,
<code>datetime:"2020-01-01T00:00:00Z"</code>. You can add and subtract <code>duration</code> from
<code>datetime</code>.</p>
<pre><code>〉datetime:"2020-01-01T00:00:00Z" + duration:30.s
-: datetime
2020-01-01 00:00:30 UTC
</code></pre>
<p>You can enter <code>datetime</code> literals in local time and they will be converted to UTC. For example,</p>
<pre><code>〉datetime:"2020-01-01T00:00:00-04:00"
-: datetime
2020-01-01 04:00:00 UTC
</code></pre>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>Strings in Graphix are UTF8 encoded text. The type name is <code>string</code> and the
literal is written in quotes <code>"this is a string"</code>. C style escape sequences are
supported, <code>"this is \" a string with a quote and a \n"</code>. Non printable
characters such as newline will be escaped by default when strings are printed
to the console, you can use <code>print</code> to print the raw string including control
characters.</p>
<h3 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h3>
<p>String literals can contain expressions that will be evaluated and joined to the string,
such expressions are surrounded by unescaped <code>[]</code> in the string. For example,</p>
<pre><code>〉let row = 1
〉let column = 999
〉"/foo/bar/[row]/[column]"
-: string
"/foo/bar/1/999"
</code></pre>
<p>Values in an interpolation need not be strings, they will be cast to a string
when they are used. You can write a literal <code>[</code> or <code>]</code> in a string by escaping
it.</p>
<pre><code>〉"this is a string with a \[ and a \] but it isn't an interpolation"
-: string
"this is a string with a [ and a ] but it isn't an interpolation"
</code></pre>
<h2 id="any"><a class="header" href="#any">Any</a></h2>
<p>The <code>Any</code> type is a type that unifies with any other type, it corresponds to the
underlying variant type that represents all values in Graphix (and netidx). It
is not used very often, as it provides very few guarantees, however it has it's
place. For example, <code>Any</code> is the type returned by <code>net::subscribe</code>, indicating
that any valid netidx value can come from the network. Usually the first thing
you do with an <code>Any</code> type is call <code>cast</code> to turn it into the type you expect (or
an error), or use a <code>select</code> expression to match it's type (more on select later).</p>
<h2 id="null"><a class="header" href="#null">Null</a></h2>
<p>Null is nothing, just like in many other languages. Unlike most other languages
<code>null</code> is a type not a catch all hack. If the type of a value does not include
<code>null</code> then it can't be null. The set <code>['a, null]</code> is commonly used instead of
an option type in Graphix, it serves the same purpose, and is more efficient,
because <code>null</code> is part of the underlying variant that represents all Graphix
values after type erasure.</p>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>Arrays in Graphix have a type parameter indicating their element type.
<code>Array&lt;string&gt;</code> indicates an array of strings. Every element of an array must be
the same type. Arrays are zero indexed <code>a[0]</code> is the first element. Arrays can
hold any Graphix type as an element, including other arrays at arbitrary levels
of nesting. There is a special type <code>Array&lt;Any&gt;</code> that can also be written as
<code>array</code> (case sensitive), that represents the fundamental array type in the
underlying value representation. <code>[x, y, z]</code> constructs a three element array.
There are many functions in the <code>array</code> module of the standard library for
working with arrays.</p>
<h3 id="array-slicing-and-indexing"><a class="header" href="#array-slicing-and-indexing">Array Slicing and Indexing</a></h3>
<p>Graphix supports array subslicing, the syntax will be familar to Rust programmers.</p>
<ul>
<li><code>a[2..]</code> a slice from index 2 to the end of the array</li>
<li><code>a[..4]</code> a slice from the beginning of the array to index 3</li>
<li><code>a[1..3]</code> a slice from index 1 to index 2</li>
<li><code>a[-1]</code> the last element in the array</li>
<li><code>a[-2]</code> the second to last element in the array</li>
</ul>
<p><code>..=</code> is not supported however, the second part of the slice will always be the
exclusive bound. Literal numbers can always be replaced with a Graphix
expression, e.g. <code>a[i..j]</code> is perfectly valid.</p>
<h3 id="mutability-and-implementation"><a class="header" href="#mutability-and-implementation">Mutability and Implementation</a></h3>
<p>Arrays are not mutable, like all other Graphix values. All operations that
"change" an array, actually create a new array leaving the old one unchanged.
This is even true of the connect operator, which we will talk more about later.</p>
<p>There are a couple of important notes to understand about the implementation of
Arrays.</p>
<ul>
<li>
<p>Arrays are memory pooled, in almost all cases (besides really huge arrays)
creating an array does not actually allocate any memory, it just reuses a
previously used array that has since become unused. This makes using arrays a
lot more efficient than you might expect.</p>
</li>
<li>
<p>Arrays are contiguous in memory, there is no funny business going on (looking
at you lua). This means they are generally very memory efficient, each element
is 3 machine words, and fast to access. However there are a few cases where
this causes a problem, such as building up an array by appending one element
at a time. This is sadly an O(N^2) operation on arrays. You may wish to use
another data structure for this kind of operation.</p>
</li>
<li>
<p>Array slices are zero copy. They do not allocate memory, and they do not clone
any of the array's elements, they simply create a light weight view into the
array. This means algorithms that progressively deconstruct an array by
slicing are O(N) not O(N^2) and the constants are very fast.</p>
</li>
</ul>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Tuples are written <code>(x, y)</code>, they can be of arbitrary length, and each element
may have a different type. Tuples may be indexed using numeric field indexes.
Consider</p>
<pre><code>let x = (1, 2, 3, 4);
x.0
</code></pre>
<p>Will print 1.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-binds"><a class="header" href="#let-binds">Let Binds</a></h1>
<p>Let bindings introduce names that are visible in their scope after they are
defined.</p>
<pre><code>let x = 2 + 2 + x; // error x isn't defined yet
let y = x + 1 // ok
</code></pre>
<p>The same name can be used again in the same scope, it will shadow the previous
value.</p>
<pre><code>let x = 1;
let x = x + 1; // ok uses the previous definition
x == 2 // true
</code></pre>
<p>You can annotate the binding with a type, which will then be enforced at compile
time. Sometimes this is necessary in order to help type inference.</p>
<pre><code>let x: Number = 1; // note x will be of type Number even though it's an i64
let y: string = x + 1; // compile time type error
</code></pre>
<p>You can use destructuring patterns in let binds as long as they will always
match.</p>
<pre><code>let (x, y) = (3, "hello"); // binds x to 3 and y to "hello"
x == 3; // true
y == "hello" // true
</code></pre>
<p>You can mix type annotations with pattern matches</p>
<pre><code>let (x, y): (i64, string) = (3, "hello")
</code></pre>
<p>You can assign documentation to a let bind using a <code>///</code> comment. Documentation
will be displayed in the shell when the user tab completes and will be made
available by the lsp server (when one exists).</p>
<pre><code>// this is a normal comment
let x = 1;
/// this is documentation for y
let y = 2;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect"><a class="header" href="#connect">Connect</a></h1>
<p>Connect, written <code>x &lt;- expr</code> is where things get interesting in Graphix. The
sharp eyed may have noticed that up until now there was no way to introduce a
cycle in the graph. Connect is the first (and really the only) graph operator in
Graphix, it allows you to connect one part of the graph to another by name,
causing the output of the right side to flow to the name on the left side.
Consider,</p>
<pre><code>let x = "off"
x &lt;- time::timer(duration:1.0s, false) ~ "on"
print(x)
</code></pre>
<p>This program will first print <code>off</code>, and after 1 second it will print <code>on</code>. Note
the <code>~</code> operator means, when the expression on the left updates return the
current value of the expression on the right (called the sample operator). The
graph we created looks like,</p>
<pre><code>const("off") ===============&gt; "x" =======&gt; print
                              ^
                              |
time::timer ====&gt; sample =====
                 ^
                 |
const("on") =====
</code></pre>
<p>We can also build an infinite loop with connect. This won't crash the program,
and it won't stop other parts of the program from being evaluated, it's a
completely legit thing to do.</p>
<pre><code>let x = 0;
x &lt;- x + 1;
print(x)
</code></pre>
<p>This program will print all the i64s from 0 to MAX and then will wrap around. It
will print numbers forever. You might notice, and you might wonder, why does it
start from zero, shouldn't it start from 1? After all we increment x BEFORE the
print right? Well, no, not actually, it will start at 0, for the same reason
this infinite loop won't lock up the program or cause other expressions not to
be evaluated. Graphix programs are evaluated in cycles, a batch of updates from
the network, timers, and other IO is processed into a set of all events that
happened "now", then the parts of the program that care about those particular
events are evaluated, and then the main loop goes back to waiting for events.</p>
<p>What connect does is it schedules an update to <code>x</code> for the next cycle, the
current cycle proceeds as normal to it's conclusion as if the connect didn't
happen yet, because it didn't. In the above case the event loop would never
wait, because there is always work to do adding 1 to <code>x</code>, however it will still
check for IO events, and any other events that might have happened.</p>
<p>When combined with other operations, specifically select, connect becomes a
powerful general looping construct, and is actually the only way to write a loop
in Graphix. A quick example,</p>
<pre><code>let count = {
  let x = 0;
  select x {
    n if n &lt; 10 =&gt; x &lt;- x + 1,
    _ =&gt; never()
  };
  x
};
count
</code></pre>
<p>This program creates a bind <code>count</code> that will update with the values 0 to 10. If
you put it in a file <code>test.gx</code> and execute it using <code>graphix ./test.gx</code> it will
print 0 to 10 and then wait.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
0
1
2
3
4
5
6
7
8
9
10
</code></pre>
<h3 id="is-connect-mutation"><a class="header" href="#is-connect-mutation">Is Connect Mutation?</a></h3>
<p>Connect causes let bound names to update, so it's kind of mutation. Kind of. A
better way to think about it is that every let bound value is a pipe with
multiple producers and multiple consumers. Connect adds a new producer to the
pipe. The values being produced are immutable, an array <code>[1, 2, 3]</code> will always
and forever be <code>[1, 2, 3]</code>, but a new array <code>[1, 2, 3, 4]</code> might be pushed into
the same pipe <code>[1, 2, 3]</code> came from, and that might make it appear that the
array changed. The difference is, if you captured the original <code>[1, 2, 3]</code> and
put it somewhere, a new <code>[1, 2, 3, 4]</code> arriving on the pipe can't change the
original array.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks"><a class="header" href="#blocks">Blocks</a></h1>
<p>A block is a group of code between <code>{</code> and <code>}</code> that has it's own scope, and
evaluates to the last value in the block. Expressions in a block are <code>;</code>
separated, meaning every expression except the last one must end in a <code>;</code> and
it is illegal for a block to have just one expression (it will not parse).</p>
<p>You can use blocks to hide intermediate variables from outer scopes, and to
group code together in a logical way.</p>
<pre><code>let important_thing = {
  let x = 0;
  let y = x + 1;
  43 - y
};

x; // compile error, x isn't in scope
y; // compile error, y isn't in scope
important_thing
</code></pre>
<p>This program won't compile because you can't reference y and x from outside the
block scope, but if you removed those refernces it would print a very important
number. Blocks are valid anywhere an expression is valid, and they are just
expressions. They will become very important when we introduce lambda
expressions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use"><a class="header" href="#use">Use</a></h1>
<p>Use allows you to bring names in modules into your current scope so they can be used without prefixing.</p>
<pre><code>net::subscribe(...); // call subscribe in the net module
use net;
subscribe(...) // same function
</code></pre>
<p>Use is valid anywhere expressions are valid</p>
<pre><code>let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
list
</code></pre>
<p>will print <code>[2, 4, 6, 8, 10]</code></p>
<pre><code>let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
map(list, |x| x * 2)
</code></pre>
<p>will not compile, e.g.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    at line: 5, column: 1 map not defined
</code></pre>
<p>Use shadows earlier declarations in it's scope. Consider,</p>
<pre><code>let map = |a, f| "hello you called map!";
let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
(list, map(list, |x| x * 2))
</code></pre>
<p>prints</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
([2, 4, 6, 8, 10], "hello you called map!")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<p>Select lets us create a graph node with multiple possible output paths that
will choose one path for each value based on a set of conditions. Kind of like,</p>
<pre><code>                   | if foo &gt; 0 =&gt;  ...
                   |
                   |
ref(foo) =&gt; select | if foo &lt; 0 =&gt; ...
                   |
                   |
                   | otherwise =&gt; ...
</code></pre>
<p>is written as</p>
<pre><code>select foo {
  n if n &gt; 0 =&gt; ...,
  n if n &lt; 0 =&gt; ...,
  n =&gt; ...
}
</code></pre>
<p>select takes an expression as an argument and then evaluates one or more "arms".
Each arm consists of an optional type predicate, a destructuring pattern, and an
optional guard clause. If the type predicate matches, the pattern matches, and
the guard evaluates to true then the arm is "selected". Only one arm may be
selected at a time, the arms are evaluated in lexical order, and first arm to be
selected is chosen as the one and only selected arm.</p>
<p>The code on the right side of the selected arm is the only code that is
evaluated by select, all other code is "asleep", it will not be evaluated
until it is selected (and if it has netidx subscriptions or published values
they will be unsubscribed and unpublished until it is selected again).</p>
<h2 id="matching-types"><a class="header" href="#matching-types">Matching Types</a></h2>
<p>Consider we want to select from a value of type <code>[Array&lt;i64&gt;, i64, null]</code>,</p>
<pre><code>let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n =&gt; n,
  null as _ =&gt; 42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures-and-first-class-functions"><a class="header" href="#closures-and-first-class-functions">Closures and First Class Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-defined-types"><a class="header" href="#user-defined-types">User Defined Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variants"><a class="header" href="#variants">Variants</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples-1"><a class="header" href="#tuples-1">Tuples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="named-types"><a class="header" href="#named-types">Named Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parametric-polymorphism"><a class="header" href="#parametric-polymorphism">Parametric Polymorphism</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-modules"><a class="header" href="#inline-modules">Inline Modules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-modules"><a class="header" href="#external-modules">External Modules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-modules"><a class="header" href="#dynamic-modules">Dynamic Modules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-standard-library"><a class="header" href="#the-standard-library">The Standard Library</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core"><a class="header" href="#core">core</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net"><a class="header" href="#net">net</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-1"><a class="header" href="#array-1">array</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="str"><a class="header" href="#str">str</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="re"><a class="header" href="#re">re</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time"><a class="header" href="#time">time</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rand"><a class="header" href="#rand">rand</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-uis-with-graphix"><a class="header" href="#building-uis-with-graphix">Building UIs With Graphix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuis"><a class="header" href="#tuis">TUIs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="barchart"><a class="header" href="#barchart">barchart</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block"><a class="header" href="#block">block</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="browser"><a class="header" href="#browser">browser</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calendar"><a class="header" href="#calendar">calendar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas"><a class="header" href="#canvas">canvas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chart"><a class="header" href="#chart">chart</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">text</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paragraph"><a class="header" href="#paragraph">paragraph</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gauge"><a class="header" href="#gauge">gauge</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linegauge"><a class="header" href="#linegauge">linegauge</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">layout</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list"><a class="header" href="#list">list</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll"><a class="header" href="#scroll">scroll</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparkline"><a class="header" href="#sparkline">sparkline</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table"><a class="header" href="#table">table</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tabs"><a class="header" href="#tabs">tabs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-graphix"><a class="header" href="#embedding-graphix">Embedding Graphix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-built-in-functions"><a class="header" href="#writing-built-in-functions">Writing Built in Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-graphix-shell"><a class="header" href="#using-graphix-shell">Using graphix-shell</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-graphix-rt"><a class="header" href="#using-graphix-rt">Using graphix-rt</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
