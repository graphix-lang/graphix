<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Graphix Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Graphix Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro-to-graphix"><a class="header" href="#intro-to-graphix">Intro to Graphix</a></h1>
<p>Graphix is a programming language using the dataflow paradigm. It is
particularly well suited to building user interfaces, and interacting with
resources in <a href="https://netidx.github.io/netidx-book">netidx</a>. Dataflow languages
like Graphix are "reactive", like the popular UI library, except at the language
level instead of just as a library. A Graphix program is compiled to a directed
graph, operations (such as +) are graph nodes, edges represent paths data can
take through the program. Consider,</p>
<pre><code>2 + 2
</code></pre>
<p>This compiles to a graph like,</p>
<p>const(2) ==&gt; + &lt;== const(2)</p>
<p>When executed the program will have 1 output, 4. Which is exactly what you'd
expect and is no different from a non data flow program. We need a
more complex example to see the difference,</p>
<pre><code>let x = cast&lt;i64&gt;(net::subscribe("/foo")?)?;
print(x * 10)
</code></pre>
<p>net::subscribe, subscribes to a netidx path and returns it's value, or an error
(more on ? later). Now lets see what happens, the graph we get from this program
looks something like this,</p>
<pre><code>                                   const(10) ==
                                                |
                                                |
                                                v
const("/foo") =&gt; net::subscribe =&gt; cast&lt;i64&gt; =&gt; * =&gt; print
</code></pre>
<p>Unlike the first example, the value of <code>net::subscribe</code> isn't a constant, it can
change if the value published in netidx changes. Graphix programs never
terminate on their own, they are just graphs, if one of their dependent nodes
changes, then they update. So if the published value of "/foo" is initially 10,
then this program will print 100, if the value of "/foo" changes to 5 then the
output of the program will change to 50, and so on forever.</p>
<p>This is a powerful way to think about programming, and it's especially well
suited to building user interfaces and transforming data streams.</p>
<p>Besides being a dataflow language Graphix tries hard to be a normal language
that would feel familiar to anyone who knows a modern functional programming
language. Some of it's features are,</p>
<ul>
<li>lexically scoped</li>
<li>expression oriented</li>
<li>strongly statically typed</li>
<li>type inference</li>
<li>structural type discipline</li>
<li>parametric polymorphism</li>
<li>algebraic data types</li>
<li>pattern matching</li>
<li>first class functions, and closures</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-graphix"><a class="header" href="#installing-graphix">Installing Graphix</a></h1>
<p>To install the Graphix shell from source you need to install a rust build
environment. See <a href="https://www.rust-lang.org/tools/install">here</a> for
instructions on how to do that for your platform. Once you have that set up, you
can just run</p>
<p><code>cargo install graphix-shell</code></p>
<p>That should build the <code>graphix</code> command and install it in your ~/.cargo/bin
directory. On linux you may need to install kerberos headers, as well as clang
libs for gssapi to build properly (on linux). On debian/ubuntu install
<code>libclang-dev</code>, and <code>libkrb5-dev</code>. On other distributions the names will be
similar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-language"><a class="header" href="#core-language">Core Language</a></h1>
<p>This section documents the core language constructs in Graphix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamental-types"><a class="header" href="#fundamental-types">Fundamental Types</a></h1>
<p>Graphix has a few fundamental data types, the Graphix shell is a good way to
explore them by trying out small Graphix expressions. You can run the Graphix
shell by invoking <code>graphix</code> with no arguments.</p>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p><code>i32</code>, <code>u32</code>, <code>i64</code>, <code>u64</code>, <code>f32</code>, <code>f64</code>, and <code>decimal</code> are the fundamental
numeric types in Graphix. Literals are written with their type prefixed, except
for <code>i64</code> and <code>f64</code> which are written bare. for example, <code>u32:3</code> is a <code>u32</code>
literal value.</p>
<p><code>decimal</code> is an exact decimal representation for performing financial
calculations without rounding or floating point approximation errors.</p>
<p>The basic arithmetic operations are implemented on all the number types with all
the other number types.</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Operator</th></tr></thead><tbody>
<tr><td>Add</td><td>+</td></tr>
<tr><td>Subtract</td><td>-</td></tr>
<tr><td>Multiply</td><td>*</td></tr>
<tr><td>Divide</td><td>/</td></tr>
<tr><td>Mod</td><td>%</td></tr>
</tbody></table>
</div>
<p>The compiler will let you do arithmatic on different types of numbers directly
without casting, however the return type of the operation will be the set of all
the types in the operation, representing that either type could be returned. If
you try to pass this result to a function that wants a specific numeric type, it
will fail at compile time.</p>
<pre><code>〉1. + 1
-: [i64, f64]
2
〉let f = |x: i64| x * 10
〉f(1. + 1)
error: in expr

Caused by:
    0: at: line: 1, column: 3, in: (f64:1. + i64:1)
    1: at: line: 1, column: 3, in: (f64:1. + i64:1)
    2: type mismatch '_1046: i64 does not contain [i64, f64]
</code></pre>
<p>Division by zero is raised as an error to the nearest error handler (more on
that later) and will be printed to stderr by the shell if it is never handled.
Overflow and underflow are handled by wrapping,</p>
<pre><code>〉0 / 0

thread 'tokio-runtime-worker' panicked at /home/eric/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:319:5:
attempt to divide by zero
-: i64
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
unhandled error: error:"in expr at line: 1, column: 1 attempt to divide by zero"
〉u32:0 - u32:1
-: u32
4294967295
</code></pre>
<p>The thread panic message is an artifact of how the overflow error is handled at
runtime, it is safe to continue using the shell and runtime if such an error
occurrs. However the particular arith operation that caused the error will not
update, which may cause problems depending on what your program is doing with
it.</p>
<h3 id="number-sets"><a class="header" href="#number-sets">Number Sets</a></h3>
<p>There are a few sets of number types that classify numbers into various kinds.
<code>Number</code> being the most broad, it contains all the number types. <code>Int</code> contains
only integers, <code>Real</code> contains only reals (decimal plus the two float types),
<code>SInt</code> contains signed integers, <code>UInt</code> contains unsigned integers.</p>
<h2 id="bool"><a class="header" href="#bool">Bool</a></h2>
<p>Boolean literals are written as <code>true</code> and <code>false</code>, and the name of the boolean
type is <code>bool</code>.</p>
<p>Boolean expressions using <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> are supported. These operators
only operate on <code>bool</code>. They can be grouped with parenthesis. For example,</p>
<pre><code>〉true &amp;&amp; false
-: bool
false
〉true || false
-: bool
true
〉!true
-: bool
false
〉!1
error: in expr

Caused by:
    0: at: line: 1, column: 2, in: i64:1
    1: type mismatch bool does not contain i64
</code></pre>
<h2 id="duration"><a class="header" href="#duration">Duration</a></h2>
<p>A time duration. The type name is <code>duration</code>, and the literals are written as,
<code>duration:1.0s</code>, <code>duration:1.0ms</code>, <code>duration:1.0us</code>, <code>duration:1.0ns</code>. Durations
can be added, and can be multiplied and divided by scalars.</p>
<pre><code>〉duration:1.0s + duration:1.0s
-: duration
2.s
〉duration:1.0s * 50
-: duration
50.s
〉duration:1.0s / 50
-: duration
0.02s
</code></pre>
<h2 id="datetime"><a class="header" href="#datetime">DateTime</a></h2>
<p>A date and time in the UTC time zone. The type name is <code>datetime</code> and literals
are written in RFC3339 format inside quotes. For example,
<code>datetime:"2020-01-01T00:00:00Z"</code>. You can add and subtract <code>duration</code> from
<code>datetime</code>.</p>
<pre><code>〉datetime:"2020-01-01T00:00:00Z" + duration:30.s
-: datetime
2020-01-01 00:00:30 UTC
</code></pre>
<p>You can enter <code>datetime</code> literals in local time and they will be converted to UTC. For example,</p>
<pre><code>〉datetime:"2020-01-01T00:00:00-04:00"
-: datetime
2020-01-01 04:00:00 UTC
</code></pre>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>Strings in Graphix are UTF8 encoded text. The type name is <code>string</code> and the
literal is written in quotes <code>"this is a string"</code>. C style escape sequences are
supported, <code>"this is \" a string with a quote and a \n"</code>. Non printable
characters such as newline will be escaped by default when strings are printed
to the console, you can use <code>print</code> to print the raw string including control
characters.</p>
<h3 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h3>
<p>String literals can contain expressions that will be evaluated and joined to the string,
such expressions are surrounded by unescaped <code>[]</code> in the string. For example,</p>
<pre><code>〉let row = 1
〉let column = 999
〉"/foo/bar/[row]/[column]"
-: string
"/foo/bar/1/999"
</code></pre>
<p>Values in an interpolation need not be strings, they will be cast to a string
when they are used. You can write a literal <code>[</code> or <code>]</code> in a string by escaping
it.</p>
<pre><code>〉"this is a string with a \[ and a \] but it isn't an interpolation"
-: string
"this is a string with a [ and a ] but it isn't an interpolation"
</code></pre>
<h2 id="any"><a class="header" href="#any">Any</a></h2>
<p>The <code>Any</code> type is a type that unifies with any other type, it corresponds to the
underlying variant type that represents all values in Graphix (and netidx). It
is not used very often, as it provides very few guarantees, however it has it's
place. For example, <code>Any</code> is the type returned by <code>net::subscribe</code>, indicating
that any valid netidx value can come from the network. Usually the first thing
you do with an <code>Any</code> type is call <code>cast</code> to turn it into the type you expect (or
an error), or use a <code>select</code> expression to match it's type (more on select later).</p>
<h2 id="null"><a class="header" href="#null">Null</a></h2>
<p>Null is nothing, just like in many other languages. Unlike most other languages
<code>null</code> is a type not a catch all. If the type of a value does not include <code>null</code>
then it can't be null. The set <code>['a, null]</code> (alias <code>Option&lt;'a&gt;</code>) is commonly
used to represent things that will sometimes return <code>null</code>.</p>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>Arrays are immutable, contiguous, and homogenous. They are parameterized,
<code>Array&lt;string&gt;</code> indicates an array of strings. Arrays are zero indexed <code>a[0]</code> is
the first element. Array elements can be any type, including other arrays at
arbitrary levels of nesting. There is a special <code>array</code> (case sensitive), that
represents the fundamental array type in the underlying value representation.
Array literals are written like <code>[x, y, z]</code>. There are many functions in the
<code>array</code> module of the standard library for working with arrays.</p>
<h3 id="array-slicing-and-indexing"><a class="header" href="#array-slicing-and-indexing">Array Slicing and Indexing</a></h3>
<p>Graphix supports array subslicing, the syntax will be familar to Rust programmers.</p>
<ul>
<li><code>a[2..]</code> a slice from index 2 to the end of the array</li>
<li><code>a[..4]</code> a slice from the beginning of the array to index 3</li>
<li><code>a[1..3]</code> a slice from index 1 to index 2</li>
<li><code>a[-1]</code> the last element in the array</li>
<li><code>a[-2]</code> the second to last element in the array</li>
</ul>
<p><code>..=</code> is not supported however, the second part of the slice will always be the
exclusive bound. Literal numbers can always be replaced with a Graphix
expression, e.g. <code>a[i..j]</code> is perfectly valid.</p>
<h3 id="mutability-and-implementation"><a class="header" href="#mutability-and-implementation">Mutability and Implementation</a></h3>
<p>Arrays are not mutable, like all other Graphix values. All operations that
"change" an array, actually create a new array leaving the old one unchanged.
This is even true of the connect operator, which we will talk more about later.</p>
<p>There are a couple of important notes to understand about the implementation of
Arrays.</p>
<ul>
<li>
<p>Arrays are memory pooled, in almost all cases (besides really huge arrays)
creating an array does not actually allocate any memory, it just reuses a
previously used array that has since become unused. This makes using arrays a
lot more efficient than you might expect.</p>
</li>
<li>
<p>Arrays are contiguous in memory, there is no funny business going on (looking
at you lua). This means they are generally very memory efficient, each element
is 3 machine words, and fast to access. However there are a few cases where
this causes a problem, such as building up an array by appending one element
at a time. This is sadly an O(N^2) operation on arrays. You may wish to use
another data structure for this kind of operation.</p>
</li>
<li>
<p>Array slices are zero copy. They do not allocate memory, and they do not clone
any of the array's elements, they simply create a light weight view into the
array. This means algorithms that progressively deconstruct an array by
slicing are O(N) not O(N^2) and the constants are very fast.</p>
</li>
</ul>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Tuples are written <code>(x, y)</code>, they can be of arbitrary length, and each element
may have a different type. Tuples may be indexed using numeric field indexes.
Consider</p>
<pre><code>let x = (1, 2, 3, 4);
x.0
</code></pre>
<p>Will print 1.</p>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<p>Maps in Graphix are key-value data structures with O(log(N)) lookup, insert, and
remove operations. Maps are parameterized by their key and value type, for
example <code>Map&lt;string, i64&gt;</code> indicates a map with string keys and integer values.
There are many functions for working with maps in the <code>map</code> standard library
module</p>
<h3 id="map-literals"><a class="header" href="#map-literals">Map Literals</a></h3>
<p>Maps can be constructed using the <code>{key =&gt; value}</code> syntax:</p>
<pre><code>〉{"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3}
-: Map&lt;'_1893: string, '_1895: i64&gt;
{"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3}
</code></pre>
<p>Keys and values can be any Graphix type, for example here is a map where the key
is a <code>Map&lt;string, i64&gt;</code>.</p>
<pre><code>{{"foo" =&gt; 42} =&gt; "foo", {"bar" =&gt; 42} =&gt; "bar"}
-: Map&lt;'_1919: Map&lt;'_1915: string, '_1917: i64&gt;, '_1921: string&gt;
{{"bar" =&gt; 42} =&gt; "bar", {"foo" =&gt; 42} =&gt; "foo"}
</code></pre>
<h3 id="map-indexing"><a class="header" href="#map-indexing">Map Indexing</a></h3>
<p>Maps can be indexed using the <code>map{key}</code> syntax to retrieve values:</p>
<pre><code>〉let m = {"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3}
〉m{"b"}
-: ['_1907: i64, Error&lt;`MapKeyError(string)&gt;]
2
</code></pre>
<p>If a key is not present in the map, indexing returns a <code>MapKeyError</code>:</p>
<pre><code>〉m{"missing"}
-: ['_1907: i64, Error&lt;`MapKeyError(string)&gt;]
error:["MapKeyError", "map key \"missing\" not found"]
</code></pre>
<h3 id="mutability-and-implementation-1"><a class="header" href="#mutability-and-implementation-1">Mutability and Implementation</a></h3>
<p>Like all Graphix values, maps are immutable. All operations that "change" a map
actually create a new map, leaving the original unchanged. Maps are memory
pooled and very efficient - creating new maps typically reuses existing memory
rather than allocating new memory.</p>
<p>Maps maintain their key-value pairs in a balanced tree structure, ensuring
O(log(N)) performance for all operations regardless of map size.</p>
<h2 id="error"><a class="header" href="#error">Error</a></h2>
<p>Error is the built in error type. It carries a type parameter indicating the
type of error, for example <code>Error&lt;`MapKeyError(string)&gt;</code> is an error that
carries a <code>`MapKeyError</code> variant. You can access the inner error value
using <code>e.0</code> e.g.,</p>
<pre><code>〉let e = error(`MapKeyError("no such key"))
〉e.0
-: `MapKeyError(string)
`MapKeyError("no such key")
</code></pre>
<p>More information about dealing with errors is available in the section on error
handling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-binds"><a class="header" href="#let-binds">Let Binds</a></h1>
<p>Let bindings introduce names that are visible in their scope after they are
defined.</p>
<pre><code>let x = 2 + 2 + x; // compile error x isn't defined yet
let y = x + 1 // ok
</code></pre>
<p>The same name can be used again in the same scope, it will shadow the previous
value.</p>
<pre><code>let x = 1;
let x = x + 1; // ok uses the previous definition
x == 2 // true
</code></pre>
<p>You can annotate the binding with a type, which will then be enforced at compile
time. Sometimes this is necessary in order to help type inference.</p>
<pre><code>let x: Number = 1; // note x will be of type Number even though it's an i64
let y: string = x + 1; // compile time type error
</code></pre>
<p>You can use patterns in let binds as long as they will always match.</p>
<pre><code>let (x, y) = (3, "hello"); // binds x to 3 and y to "hello"
x == 3; // true
y == "hello" // true
</code></pre>
<p>You can mix type annotations with pattern matches</p>
<pre><code>let (x, y): (i64, string) = (3, "hello")
</code></pre>
<p>You can assign documentation to a let bind using a <code>///</code> comment. Documentation
will be displayed in the shell when the user tab completes and will be made
available by the lsp server.</p>
<pre><code>// this is a normal comment
let x = 1;
/// this is documentation for y
let y = 2;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect"><a class="header" href="#connect">Connect</a></h1>
<p>Connect, written <code>x &lt;- expr</code> is where things get interesting in Graphix. The
sharp eyed may have noticed that up until now there was no way to introduce a
cycle in the graph. Connect is the only graph operator in Graphix, it allows you
to connect one part of the graph to another by name, causing the output of the
right side to flow to the name on the left side. Consider,</p>
<pre><code>let x = "off"
x &lt;- time::timer(duration:1.0s, false) ~ "on"
print(x)
</code></pre>
<p>This program will first print <code>off</code>, and after 1 second it will print <code>on</code>. Note
the <code>~</code> operator means, when the expression on the left updates return the
current value of the expression on the right (called the sample operator). The
graph we created looks like,</p>
<pre><code>const("off") ===============&gt; "x" =======&gt; print
                              ^
                              |
time::timer ====&gt; sample =====
                 ^
                 |
const("on") =====
</code></pre>
<p>We can also build an infinite loop with connect. This won't crash the program,
and it won't stop other parts of the program from being evaluated,</p>
<pre><code>let x = 0;
x &lt;- x + 1;
print(x)
</code></pre>
<p>This program will print all the i64s from 0 to MAX and then will wrap around. It
will print numbers forever. You might notice, and you might wonder, why does it
start from zero, shouldn't it start from 1? After all we increment x BEFORE the
print right? Well, no, not actually, it will start at 0, for the same reason
this infinite loop won't lock up the program or cause other expressions not to
be evaluated. Graphix programs are evaluated in cycles, a batch of updates from
the network, timers, and other IO is processed into a set of all events that
happened "now", then the parts of the program that care about those particular
events are evaluated, and then the main loop goes back to waiting for events.</p>
<p>What connect does is it schedules an update to <code>x</code> for the next cycle, the
current cycle proceeds as normal to it's conclusion as if the connect didn't
happen yet, because it didn't. In the above case the event loop would never
wait, because there is always work to do adding 1 to <code>x</code>, however it will still
check for other events every cycle.</p>
<p>When combined with other operations, specifically select, connect becomes a
powerful general looping construct, and is the only way to write a loop in
Graphix. A quick example,</p>
<pre><code>let count = {
  let x = 0;
  select x {
    n if n &lt; 10 =&gt; x &lt;- x + 1,
    _ =&gt; never() // never() never updates
  };
  x
};
count
</code></pre>
<p>This program creates a bind <code>count</code> that will update with the values 0 to 10. If
you put it in a file <code>test.gx</code> and execute it using <code>graphix ./test.gx</code> it will
print 0 to 10 and then wait.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
0
1
2
3
4
5
6
7
8
9
10
</code></pre>
<h3 id="is-connect-mutation"><a class="header" href="#is-connect-mutation">Is Connect Mutation?</a></h3>
<p>Connect causes let bound names to update, so it's kind of mutation. Kind of. A
better way to think about it is that every let bound value is a pipe with
multiple producers and multiple consumers. Connect adds a new producer to the
pipe. The values being produced are immutable, an array <code>[1, 2, 3]</code> will always
and forever be <code>[1, 2, 3]</code>, but a new array <code>[1, 2, 3, 4]</code> might be pushed into
the same pipe <code>[1, 2, 3]</code> came from, and that might make it appear that the
array changed. The difference is, if you captured the original <code>[1, 2, 3]</code> and
put it somewhere, a new <code>[1, 2, 3, 4]</code> arriving on the pipe can't change the
original array.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks"><a class="header" href="#blocks">Blocks</a></h1>
<p>A block is a group of code between <code>{</code> and <code>}</code> that has it's own scope, and
evaluates to the last value in the block. Expressions in a block are <code>;</code>
separated, meaning every expression except the last one must end in a <code>;</code> and
it is illegal for a block to have just one expression (it will not parse).</p>
<p>You can use blocks to hide intermediate variables from outer scopes, and to
group code together in a logical way.</p>
<pre><code>let important_thing = {
  let x = 0;
  let y = x + 1;
  43 - y
};

x; // compile error, x isn't in scope
y; // compile error, y isn't in scope
important_thing
</code></pre>
<p>This program won't compile because you can't reference y and x from outside the
block scope, but if you removed those refernces it would print a very important
number. Blocks are valid anywhere an expression is valid, and they are just
expressions. They will become very important when we introduce lambda
expressions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use"><a class="header" href="#use">Use</a></h1>
<p>Use allows you to bring names in modules into your current scope so they can be used without prefixing.</p>
<pre><code>net::subscribe(...); // call subscribe in the net module
use net;
subscribe(...) // same function
</code></pre>
<p>Use is valid anywhere expressions are valid</p>
<pre><code>let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
list
</code></pre>
<p>will print <code>[2, 4, 6, 8, 10]</code></p>
<pre><code>let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
map(list, |x| x * 2)
</code></pre>
<p>will not compile, e.g.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    at line: 5, column: 1 map not defined
</code></pre>
<p>Use shadows earlier declarations in it's scope. Consider,</p>
<pre><code>let map = |a, f| "hello you called map!";
let list = {
  use array;
  map([1, 2, 3, 4, 5], |x| x * 2)
};
(list, map(list, |x| x * 2))
</code></pre>
<p>prints</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
([2, 4, 6, 8, 10], "hello you called map!")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<p>Select lets us create a graph node with multiple possible output paths that
will choose one path for each value based on a set of conditions. Kind of like,</p>
<pre><code>                   | if foo &gt; 0 =&gt;  ...
                   |
                   |
ref(foo) =&gt; select | if foo &lt; 0 =&gt; ...
                   |
                   |
                   | otherwise =&gt; ...
</code></pre>
<p>is written as</p>
<pre><code>select foo {
  n if n &gt; 0 =&gt; ...,
  n if n &lt; 0 =&gt; ...,
  n =&gt; ...
}
</code></pre>
<p>select takes an expression as an argument and then evaluates one or more "arms".
Each arm consists of an optional type predicate, a destructuring pattern, and an
optional guard clause. If the type predicate matches, the pattern matches, and
the guard evaluates to true then the arm is "selected". Only one arm may be
selected at a time, the arms are evaluated in lexical order, and first arm to be
selected is chosen as the one and only selected arm.</p>
<p>The code on the right side of the selected arm is the only code that is
evaluated by select, all other code is "asleep", it will not be evaluated
until it is selected (and if it has netidx subscriptions or published values
they will be unsubscribed and unpublished until it is selected again).</p>
<h2 id="matching-types"><a class="header" href="#matching-types">Matching Types</a></h2>
<p>Consider we want to select from a value of type <code>[Array&lt;i64&gt;, i64, null]</code>,</p>
<pre><code>let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n =&gt; n,
  null as _ =&gt; 42
}
</code></pre>
<p>This program will print 42, 15, 7 and then wait. The compiler will check that
you have handled all the possible cases. If we remove the null case from this
select we will get a compile error.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    missing match cases type mismatch [i64, Array&lt;i64&gt;] does not contain [[i64, null], Array&lt;i64&gt;]
</code></pre>
<p>If you read this carefully you can see that the compiler is building up a set of
types that we did match, and checking that it contains the argument type. This
goes both ways, a match case that could never match is also an error.</p>
<pre><code>let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n =&gt; n,
  f64 as n =&gt; cast&lt;i64&gt;(n)?,
  null as _ =&gt; 42
}
</code></pre>
<p>Here we've added an <code>f64</code> match case, but the argument type can never contain an
<code>f64</code> so we will get a compile error.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    pattern f64 will never match null, unused match cases
</code></pre>
<p>The diagnostic message gives you an insight into the compiler's thinking. What
it is saying is that, by the time it's gotten to looking at the <code>f64</code> pattern,
the only type left in the argument that hasn't already been matched is <code>null</code>,
and since <code>f64</code> doesn't unify with <code>null</code> it is sure this pattern can never
match.</p>
<p>Guarded patterns can always not match because of the guard, so they do not
subtract from the argument type set. You are required to match without a guard
at some point. No analysis is done to determine if your guard covers the entire
range of a type.</p>
<pre><code>let x: [Array&lt;i64&gt;, i64, null] = null;
x &lt;- time::timer(duration:1.s, false) ~ [1, 2, 3, 4, 5];
x &lt;- time::timer(duration:2.s, false) ~ 7;
select x {
  Array&lt;i64&gt; as a =&gt; array::fold(a, 0, |s, x| s + x),
  i64 as n if n &gt; 10 =&gt; n,
  null as _ =&gt; 42
}
</code></pre>
<p>This will fail with a missing match case because the <code>i64</code> pattern is guarded
and no unguarded pattern exists that matches <code>i64</code>.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    missing match cases type mismatch [null, Array&lt;i64&gt;] does not contain [[i64, null], Array&lt;i64&gt;]
</code></pre>
<p>This is the same error you would get if you omitted the <code>i64</code> match case
entirely.</p>
<h2 id="matching-structure"><a class="header" href="#matching-structure">Matching Structure</a></h2>
<p>The type predicate is optional in a pattern, and the more commonly used pattern
is structural. Graphix supports several kinds of structural matching,</p>
<ul>
<li>array slices</li>
<li>tuples</li>
<li>structs</li>
<li>variants</li>
<li>literals, ignore</li>
</ul>
<p>NB: In most contexts you can match the entire value as well as parts of it's
structure by adding a <code>v@</code> pattern before the pattern. You will see this in many
of the examples.</p>
<h3 id="slice-patterns"><a class="header" href="#slice-patterns">Slice Patterns</a></h3>
<p>Suppose we want to classify arrays that have at least two elements vs arrays
that don't, and we want to return a variant with a triple of the first two
elements and the rest of the array or `Short with the whole array.</p>
<pre><code>let a = [1, 2, 3, 4];
a &lt;- [1];
a &lt;- [5, 6];
select a {
  [x, y, tl..] =&gt; `Ok((x, y, tl)),
  a =&gt; `Short(a)
}
</code></pre>
<p>This program will print,</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
`Ok((1, 2, [3, 4]))
`Short([1])
`Ok((5, 6, []))
</code></pre>
<p>The following kinds of slice patterns are supported,</p>
<ul>
<li>
<p>whole slice, with binds, or literals, e.g. <code>[1, x, 2, y]</code> matches a 4 element
array and binds it's 2nd and 4th element to <code>x</code> and <code>y</code> respectivly.</p>
</li>
<li>
<p>head pattern, like the above program, e.g. <code>[(x, y), ..]</code> matches the first
pair in an array of pairs and ignores the rest of the array, binding the pair
elements to <code>x</code> and <code>y</code>. You can also name the remainder, as we saw, e.g.
<code>[(x, y), tl..]</code> does the same thing, but binds the rest of the array to <code>tl</code></p>
</li>
<li>
<p>tail pattern, just like the head pattern, but for the end of the array. e.g.
<code>[hd.., {foo, bar}]</code> matches the last element of an array of structs with
fields <code>foo</code> and <code>bar</code>, binding <code>hd</code> to the array minus the last element, and
<code>foo</code> to field foo and <code>bar</code> to field bar.</p>
</li>
</ul>
<p>Structure patterns (all of the differnt types) can be nested to any depth.</p>
<h3 id="tuple-patterns"><a class="header" href="#tuple-patterns">Tuple Patterns</a></h3>
<p>Tuple patterns allow you to match tuples. Compared to slice patterns they are
fairly simple. You must specify every field of the tuple, you can choose to bind
it, or ignore it with <code>_</code>. e.g.</p>
<p><code>("I", "am", "a", "happy", "tuple", w, _, "patterns")</code></p>
<h3 id="struct-patterns"><a class="header" href="#struct-patterns">Struct Patterns</a></h3>
<p>Struct patterns, like tuple patterns, are pretty simple.</p>
<ul>
<li><code>{ x, y }</code> if you like the field names then there is no need to change them</li>
<li><code>{ x: x_coord, y: y_coord }</code> but if you need to use a different name you can</li>
<li><code>{ x, .. }</code> you don't have to write every field</li>
</ul>
<p>Consider</p>
<pre><code>let a = {x: 54, y: 23};
a &lt;- {x: 21, y: 88};
a &lt;- {x: 5, y: 42};
a &lt;- {x: 23, y: 32};
select a {
  {x, y: _} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall,
  {y, x: _} if (y &lt; 10) || (y &gt; 40)  =&gt; `HWall,
  {x, y} =&gt; `Ok(x, y)
}
</code></pre>
<p>does some 2d bounds checking, and will output</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
`VWall
`HWall
`VWall
`Ok(23, 32)
</code></pre>
<p>You might be tempted to replace <code>y: _</code> with <code>..</code> as it would be shorter.
Unfortunatly this will confuse the type checker, because the Graphix type system
is structural saying <code>{x, ..}</code> without any other information could match ANY
struct with a field called <code>x</code>. This is currently too much for the type checker
to handle,</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    pattern {x: '_1040} will never match {x: i64, y: i64}, unused match cases
</code></pre>
<p>The error is slightly confusing at first, until you understand that since we
don't know the type of <code>{x, ..}</code> we don't think it will match the argument type,
and therefore the match case is unused. This actually saves us a lot of trouble
here, because the last match is exhaustive, if we didn't check for unused match
cases this program would compile, but it wouldn't work. You can easily fix this
by naming the type, and for larger structs it's often worth it if you only need
a few fields.</p>
<pre><code>type T = {x: i64, y: i64};
let a = {x: 54, y: 23};
a &lt;- {x: 21, y: 88};
a &lt;- {x: 5, y: 42};
a &lt;- {x: 23, y: 32};
select a {
  T as {x, ..} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall,
  T as {y, ..} if (y &lt; 10) || (y &gt; 40)  =&gt; `HWall,
  {x, y} =&gt; `Ok(x, y)
}
</code></pre>
<p>Here since we've included the type pattern <code>T</code> in our partial patterns the
program compiles and runs.</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
`VWall
`HWall
`VWall
`Ok(23, 32)
</code></pre>
<p>Note that we never told the compiler that <code>a</code> is of
type <code>T</code>. In fact <code>T</code> is just an alias for <code>{x: i64, y: i64}</code> which is the type
of <code>a</code>. We could in fact write our patterns without the alias,</p>
<p><code>{x: i64, y: i64} as {x, ..} if (x &lt; 10) || (x &gt; 50) =&gt; `VWall</code></p>
<p>The type alias just makes the code less verbose without changing the semantics.</p>
<h3 id="variant-patterns"><a class="header" href="#variant-patterns">Variant Patterns</a></h3>
<p>Variant patterns match variants. Consider,</p>
<pre><code>let v: [`Bare, `Arg(i64), `MoreArg(string, i64)] = `Bare;
v &lt;- `Arg(42);
v &lt;- `MoreArg("hello world", 42);
select v {
  `Bare =&gt; "it's bare, no argument",
  `Arg(i) =&gt; "it has an arg [i]",
  x@ `MoreArg(s, n) =&gt; "it's big [x] with args \"[s]\" and [n]"
}
</code></pre>
<p>produces</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
"it's bare, no argument"
"it has an arg 42"
"it's big `MoreArg(\"hello world\", 42) with args \"hello world\" and 42"
</code></pre>
<p>Variant patterns enforce the same kinds of match case checking as all the other pattern types</p>
<pre><code>let v: [`Bare, `Arg(i64), `MoreArg(string, i64)] = `Bare;
v &lt;- `Arg(42);
v &lt;- `MoreArg("hello world", 42);
select v {
  `Bare =&gt; "it's bare, no argument",
  `Arg(i) =&gt; "it has an arg [i]",
  x@ `MoreArg(s, n) =&gt; "it's big [x] with args \"[s]\" and [n]",
  `Wrong =&gt; "this won't compile"
}
</code></pre>
<p>yields</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    pattern `Wrong will never match [`Arg(i64), `MoreArg(string, i64)], unused match cases
</code></pre>
<h3 id="literals-ignore"><a class="header" href="#literals-ignore">Literals, Ignore</a></h3>
<p>You can match literals as well as bind variables, as you may have noticed, and
the special pattern <code>_</code> means match anything and don't bind it to a variable.</p>
<h3 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h3>
<p>A significant missing feature from patterns vs other languages is support for
multiple alternative patterns in one arm. I plan to add this at some point.</p>
<h2 id="select-and-connect"><a class="header" href="#select-and-connect">Select and Connect</a></h2>
<p>Using select and connect together is one way to iterate in Graphix. Consider,</p>
<pre><code>let a = [1, 2, 3, 4, 5];
let len = 0;
select a {
  [x, tl..] =&gt; {
    len &lt;- len + 1;
    a &lt;- tl
  },
  _ =&gt; len
}
</code></pre>
<p>produces</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
5
</code></pre>
<p>This is not normally how we would get the length of an array in Graphix, or even
how we would do something with every element of an array (see <code>array::map</code> and
<code>array::fold</code>), however it illustrates the power of select and connect together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Errors in Graphix are represented by the <code>Error&lt;'a&gt;</code> type. A new instance of
which can be created with the <code>error</code> function. e.g.</p>
<pre><code>〉error(`Foo)
-: Error&lt;'a: `Foo&gt;
error:"Foo"
</code></pre>
<h2 id="try-catch-and-"><a class="header" href="#try-catch-and-">Try Catch and ?</a></h2>
<p>While errors are normal values, and can be matched in select, they can also be
thrown and handled like exceptions. The <code>?</code> operator throws errors generated by
the expression on it's left to the nearest try catch block in dynamic scope. for
example,</p>
<pre><code>〉let a = [1, 2, 3, 4]
〉try a[15]? catch(e) =&gt; println(e)
-: i64
error:[["cause", null], ["error", ["ArrayIndexError", "array index out of bounds"]], ["ori", [["parent", null], ["source", "Unspecified"], ["text", "try a[15]? catch(e) =&gt; println(e)"]]], ["pos", [["column", i32:5], ["line", i32:1]]]]
</code></pre>
<p>Catches the array index error and prints it's full context to stdout. Every
error raised with <code>?</code> is wrapped in an <code>ErrChain</code> struct, the full definition of
which is,</p>
<pre><code>type Pos = {
    line: i32,
    column: i32
};

type Source = [
    `File(string),
    `Netidx(string),
    `Internal(string),
    `Unspecified
];

type Ori = {
    parent: [Ori, null],
    source: Source,
    text: string
};

type ErrChain&lt;'a&gt; = {
    cause: [ErrChain&lt;'a&gt;, null],
    error: 'a,
    ori: Ori,
    pos: Pos
}
</code></pre>
<p>This gives the full context of where the error happened, and whether it was
previously caught and reraised, giving the full history back to the first time
it was ever raised.</p>
<p>The scope is dynamic, not lexical, mirroring exception systems that unwind the
stack,</p>
<pre><code>〉let div0 = try |x| x / 0 catch(e) =&gt; println(e ~ "never triggered")
〉try div0(0) catch(e) =&gt; println(e)
-: i64
error:[["cause", null], ["error", ["ArithError", "attempt to divide by zero"]], ["ori", [["parent", null], ["source", "Unspecified"], ["text", "let div0 = try |x| x / 0 catch(e) =&gt; println(e ~ \"never triggered\")"]]], ["pos", [["column", i32:20], ["line", i32:1]]]]
</code></pre>
<p>The catch surrounding the function call site, not the definition site, is the
one triggered.</p>
<h3 id="try-catch-block-value"><a class="header" href="#try-catch-block-value">Try Catch Block Value</a></h3>
<p>The try catch block always evaluates to the last value inside the try catch,
never to the value of the catch block. An error being raised to try catch does
not stop the execution of nodes in the try catch.</p>
<h2 id="checked-errors"><a class="header" href="#checked-errors">Checked Errors</a></h2>
<p>Graphix function types are annotated by the type of error they might raise. In
most cases this is automatic, but for some higher order functions it may be
neccessary to specify it explicitly. For example array map has type
<code>fn(Array&lt;'a&gt;, fn('a) -&gt; 'b throws 'e) -&gt; Array&lt;'b&gt; throws 'e</code> indicating that
while the map function itself does not throw any errors, it will throw any
errors the function passed to it throws. This is all in the service of being
able to statically check the type of thrown errors, for example,</p>
<pre><code>let a = [0, 1, 2, 3];
try a[0]? + a[1]?
catch(e) =&gt; select (e.0).error {
    `ArithError(s) =&gt; println("arithmetic operation error [s]"),
    `ArrayIndexError(s) =&gt; println("array index error [s]")
}
</code></pre>
<p>There are two types of errors that can happen in this example, and the compiler
knows that. If you were to omit one of them, then the example would not compile.
Suppose we remove the pattern for ArrayIndexError, we would get,</p>
<pre><code>Error: in file "/home/eric/test.gx"

Caused by:
    0: at: line: 3, column: 13, in: select (e.0).error {`ArithError(s) =&gt; ..
    1: missing match cases type mismatch `ArithError('_1897: string) does not contain '_1895: [`ArithError(string), `ArrayIndexError(string)]
</code></pre>
<p>You'll recognize that this is just the normal select exhaustivness checking at
work. Since errors are just normal types, the important point is the compiler
knows the type of every error at compile time, everything else flows from there.</p>
<h2 id="unhandled-errors"><a class="header" href="#unhandled-errors">Unhandled Errors</a></h2>
<p>By default when evaluating a file, the compiler will print a warning whenever an
error raised by <code>?</code> is not handled explicitly by a try catch block. Arithmetic
errors such as overflow do not generate this warning by default. Using <code>-W</code>
flags you can change the compilers behavior in this respect.</p>
<h2 id="the--operator-aka-or-never"><a class="header" href="#the--operator-aka-or-never">The $ Operator, aka Or Never</a></h2>
<p>The <code>$</code> operator goes in the same position as <code>?</code>, and is best described as "or
never". It the expression on it's left is a non error, then <code>$</code> doesn't do
anything, otherwise it returns nothing. This is a concise way of writing,</p>
<pre><code>select might_fail(1, 2, 3) {
  error as _ =&gt; never(),
  v =&gt; v
}
</code></pre>
<p>can instead be written as,</p>
<pre><code>might_fail(1, 2, 3)$
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are first class values. They can be stored in variables, in data
structures, and they can be passed around to other functions. Etc. They are
defined with the syntax,</p>
<pre><code>|arg0, arg1, ...| body
</code></pre>
<p>This is often combined with a let bind to make a named function.</p>
<pre><code>let f = |x, y| x + y + 1
</code></pre>
<p><code>f</code> is now bound to the lambda that adds it's two arguments and 1. You can also
use structure patterns in function arguments as long as the pattern will always
match.</p>
<pre><code>let g =|(x, y), z| x + y + z
</code></pre>
<p>Type annotations can be used to constrain the argument types and the return
type,</p>
<pre><code>let g = |(x, y): (f64, f64), z: f64| -&gt; f64 x + y + z
</code></pre>
<p>Functions are called with the following syntax.</p>
<pre><code>f(1, 1)
</code></pre>
<p>Would return 3. If the function is stored in a data structure, then sometimes
you need parenthesis to call it.</p>
<pre><code>(s.f)(1, 1)
</code></pre>
<p>Would call the function <code>f</code> in the struct <code>s</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="labeled-and-optional-arguments"><a class="header" href="#labeled-and-optional-arguments">Labeled and Optional Arguments</a></h1>
<p>Functions can have labeled and also optional arguments. Labeled arguments need
not be specified in order, and optional arguments don't need to be specified at
all. When declaring a function you must specify the labeled and optional
arguments before any non labeled arguments.</p>
<pre><code>let f = |#lbl1, #lbl2, arg| ...
</code></pre>
<p>In this case lbl1 and 2 are not optional, but are labeled. You can call f with
either labeled argument in either order. e.g. <code>f(#lbl2, #lbl1, a)</code>.</p>
<pre><code>let f = |#opt = null, a| ...
</code></pre>
<p><code>opt</code> need not be specifed when <code>f</code> is called, if it isn't specified then it
will be <code>null</code>. e.g. <code>f(2)</code> is a valid way to call <code>f</code>. You can also apply type
constraints to labeled and optional arguments.</p>
<pre><code>let f = |#opt: [i64, null] = null, a| ..
</code></pre>
<p>Specifies that <code>opt</code> can be either an <code>i64</code> or <code>null</code> and by default it is null.
The compiler implements subtyping for functions with optional arguments. For
example if you write a function that takes a function with a labeled argument
<code>foo</code>, you can pass any function that has a labeled argument <code>foo</code>, even if it
also has other optional arguments. The non optional and non labeled arguments
must match, of course. For example,</p>
<pre><code>let f = |g: fn(#foo:i64, i64) -&gt; i64, x: i64| g(#foo:x, x);
let g = |#foo:i64, #bar: i64 = 0, x: i64| foo + bar + x;
f(g, 42) // valid call
</code></pre>
<p>outputs</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
84
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexical-closures"><a class="header" href="#lexical-closures">Lexical Closures</a></h1>
<p>Functions can reference variables outside of their definition. These variables
are captured by the function definition, and remain valid no matter where the
closure is called. For example,</p>
<pre><code>let f = {
  let v = cast&lt;i64&gt;(net::subscribe("/local/foo")$)$;
  |n| v + n
};
f(2)
</code></pre>
<p><code>f</code> captures <code>v</code> and can use it even when it is called from a scope where <code>v</code>
isn't visible. Closures allow functions to encapsulate data, just like an object
in OOP.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-are-first-class-values"><a class="header" href="#functions-are-first-class-values">Functions are First Class values</a></h1>
<p>We can store a function in a structure, which can itself be stored in a data
structure, a file, or even sent across the network to another instance of the
same program. Here we build a struct that maintains a count, and a function to
operate on the count, returning a new struct of the same type with a different
count.</p>
<pre><code>type T = { count: i64, f: fn(T) -&gt; T };
let t = { count: 0, f: |t: T| {t with count: t.count + 1} };
(t.f)(t)
</code></pre>
<p>when run this example will output,</p>
<pre><code>{count: 1, f: 158}
</code></pre>
<p>158 is the lambda id, it's the actual value that is stored to represent a
function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="late-binding"><a class="header" href="#late-binding">Late Binding</a></h1>
<p>Functions are always late bound. Late binding means that the runtime actually
figures out which function is going to be called at runtime, not compile time.
At compile time we only know the type of the function we are going to call. This
complicates the compiler significantly, but it is a powerful abstraction tool.
For example we can create two structs of type <code>T</code> that each contain a different
implementation of <code>f</code>, and we can use them interchangibly with any function that
accepts a <code>T</code>. In this simple example we create one implementation of <code>f</code> that
increments the count, and one that decrements it.</p>
<pre><code>type T = { count: i64, f: fn(T) -&gt; T };
let ts: Array&lt;T&gt; = [
  { count: 0, f: |t: T| {t with count: t.count + 1} },
  { count: 0, f: |t: T| {t with count: t.count - 1} }
];
let t = array::iter(ts);
(t.f)(t)
</code></pre>
<p>when run this example will output,</p>
<pre><code>{count: 1, f: 158}
{count: -1, f: 159}
</code></pre>
<p>You can clearly see that f is bound to different functions by the runtime since
the lambda ids (158 and 159) are different. While Graphix is not an object
oriented language, you can use closures and late binding to achieve some of the
same outcomes as OOP.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<p>All functions are polymorphic, even without annotations, argument and return
types are inferred at each call site, and thus may differ from one site to
another. Any internal constraints are calculated when the definition is compiled
and are enforced at each call site. For example consider,</p>
<pre><code>〉let f = |x, y| x + y
〉f
-: fn&lt;'_2073: unbound: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;, '_2069: unbound: Number, '_2067: unbound: Number, '_2071: unbound: Number&gt;('_2067: unbound, '_2069: unbound) -&gt; '_2071: unbound throws '_2073: unbound
159
</code></pre>
<p>The type is a bit of a mouthfull, lets format it a bit so it's easier to read.</p>
<pre><code>fn&lt;'_2073: unbound: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;,
   '_2069: unbound: Number,
   '_2067: unbound: Number,
   '_2071: unbound: Number&gt;
('_2067: unbound, '_2069: unbound) -&gt; '_2071: unbound throws '_2073: unbound
</code></pre>
<p>After fn the stuff between the <code>&lt;&gt;</code> are the type constraints, the syntax in this
readout is a colon separated list of,</p>
<ul>
<li>type variable name, for example '_2073</li>
<li>current value, or unbound if there is no current value</li>
<li>constraint type</li>
</ul>
<p>We can remove the (unbound) current values and it becomes even easier to read,</p>
<pre><code>fn&lt;'_2073: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;,
   '_2069: Number,
   '_2067: Number,
   '_2071: Number&gt;
('_2067, '_2069) -&gt; '_2071 throws '_2073
</code></pre>
<p>Here we can see that <code>'_2067</code>, <code>'_2069</code>, and <code>'_2071</code> represent the two
arguments and the return type of the function. They are all unbound, meaning
that when the function is used they can have any type. They are also all
constrained to <code>Number</code>, and this will be enforced when the function is called,
it's arguments must be numbers and it will return a number. We learned this
because internally the function uses <code>+</code>, which operates on numbers, this
constraint was then propagated to the otherwise free variables representing the
args and the return type.</p>
<p>So in plain English this says that the arguments to the function can by any type
as long as it is a number, and the function will return some type which is a
number. None of the three numbers need to be the same type of number.</p>
<p>Finally lets address <code>throws '_2073</code>. This states that the function may throw an
error, and if it does it's type will be <code>'_2073</code>, which in this case is
constrained to be</p>
<p><code>Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;</code>.</p>
<p>This is what happens in the case of overflow, underflow, and other arithmetic
errors. The <code>throws</code> clause of the type is used by the <code>try catch(e) =&gt; ...</code>
expression to compute the type of <code>e</code>, which is just the union of all the throws
types within the <code>try catch</code>.</p>
<p>We can indeed call <code>f</code> with different number types, and it works just fine,</p>
<pre><code>〉f(1.0, 1)
-: Number
2
</code></pre>
<p>The type we get back really depends on the values we pass. For example,</p>
<pre><code>〉f(1.1212, 1)
-: Number
2.1212
</code></pre>
<p>Wherever we use <code>f</code> the compiler will force us to handle every possible case in
the <code>Number</code> type</p>
<h2 id="explicit-type-specifications"><a class="header" href="#explicit-type-specifications">Explicit Type Specifications</a></h2>
<p>While the compiler does a pretty good job of inferring the types of functions,
sometimes you want to express a constraint that can't be inferred. Suppose we
wanted to modify the example in the last section to say that while you can pass
any type of number to <code>f</code>, it has to be the same type for both arguments, and
the return type will be the same as the argument type. We can say that using
type annotations.</p>
<pre><code>〉let f = 'a: Number |x: 'a, y: 'a| -&gt; 'a x + y
〉f
-: fn&lt;'a: unbound: Number, '_2101: unbound: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;&gt;('a: unbound, 'a: unbound) -&gt; 'a: unbound throws '_2101: unbound
160
</code></pre>
<p>In type annotations of lambda expressions,</p>
<ul>
<li>The constraints come before the first <code>|</code>, separated by commas if there are
multiple constrained type variables. e.g. <code>'a: Number</code></li>
<li>Each argument may optionally have a <code>: Type</code> after it, and this will set it's
type, e.g. <code>x: 'a</code></li>
<li>After the second <code>|</code> you can optionally include an <code>-&gt; Type</code> which will set
the return type of the function, e.g. <code>-&gt; 'a</code></li>
<li>After the return type, you can optionally specify a throws type, <code>throws Type</code>, which will set the type that is thrown by the function</li>
</ul>
<p>The type we ended up with is actually quite a bit simpler, but lets format it
anyway,</p>
<pre><code>fn&lt;'a: Number,
   '_2101: Error&lt;ErrChain&lt;`ArithError(string)&gt;&gt;&gt;
('a, 'a) -&gt; 'a throws '_2101
</code></pre>
<p>We just have two variables now, <code>'a</code> representing both argument types and the
return type, and <code>'_2101</code> representing the throws type. We can still call this <code>f</code> with any number type,</p>
<pre><code>〉f(1.212, 2.0)
-: f64
3.2119999999999997
</code></pre>
<p>However notice that we get back the explicit type we passed in,</p>
<pre><code>〉f(2, 2)
-: i64
4
</code></pre>
<p>In one case <code>f64</code>, in the other <code>i64</code>. We can't pass numbers of different types,</p>
<pre><code>〉f(1, 1.2)
error: in expr

Caused by:
    0: at: line: 1, column: 6, in: f64:1.2
    1: type mismatch 'a: i64 does not contain f64
</code></pre>
<p>Here the compiler is saying that <code>'a</code> is already initialized as <code>i64</code> and <code>i64</code>
doesn't unify with <code>f64</code>.</p>
<h2 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher Order Functions</a></h2>
<p>Since functions are first class, they can take other functions as arguments, and
even return functions. These relationships can be often inferred automatically
without issue, but sometimes annotations are required.</p>
<pre><code>〉 let apply = |x: 'a, f: fn('a) -&gt; 'b throws 'e| -&gt; 'b throws 'e f(x)
〉 apply
-: fn&lt;'e: unbound: _&gt;('a: unbound, fn('a: unbound) -&gt; 'b: unbound throws 'e: unbound) -&gt; 'b: unbound throws 'e: unbound
163
</code></pre>
<p>Here we've specified a single argument apply, it takes an argument, and a
function <code>f</code>, and calls <code>f</code> on the argument. Note that we've explicitly said
that whatever type of error <code>f</code> throws, <code>apply</code> will throw as well. That was
constrained by the compiler to <code>_</code> meaning basically this could throw anything
or also not throw at all, it just depends on <code>f</code>.</p>
<p>We can see a more practical example in the type of <code>array::map</code> (this
implementation of which I will not repeat here), which is,</p>
<pre><code>fn(Array&lt;'a&gt;, fn('a) -&gt; 'b throws 'e) -&gt; Array&lt;'b&gt; throws 'e
</code></pre>
<p>So map takes an array of <code>'a</code>, and a function mapping <code>'a</code> to <code>'b</code> and possibly
throwing <code>'e</code> and returns an array of <code>'b</code> possibly throwing <code>'e</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<p>Functions can be recursive, however there is currently no tail call optimization,
so you can easily exhaust available stack space. With that warning aside, lets
write a recursive function to add up pairs of numbers in an array,</p>
<pre><code>let rec add_pairs = 'a: Number |a: Array&lt;'a&gt;| -&gt; Array&lt;'a&gt; select a {
  [e0, e1, tl..] =&gt; array::push_front(add_pairs(tl), e0 + e1),
  a =&gt; a
}
</code></pre>
<p>running this we see,</p>
<pre><code>〉add_pairs([1, 2, 3, 4, 5])
-: Array&lt;'a: i64&gt;
[3, 7, 5]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="detailed-semantics"><a class="header" href="#detailed-semantics">Detailed Semantics</a></h1>
<p>Considering the underlying execution model functions might be better described
as "polymorphic graph templates", in that they allow you to specify a part of
the graph once, and then use it multiple times with different types each time.
Most of the time this difference in semantics doesn't matter. Most of the time.
Consider,</p>
<pre><code>let n = cast&lt;i64&gt;(net::subscribe("/hev/stats/power")?)?;
f(n, 1)
</code></pre>
<p>What happens here? Does <code>f</code> get "called" every time <code>n</code> updates? Does it only
work for the first <code>n</code>? Does it explode? Lets transform it like the compiler
would in order to understand it better,</p>
<pre><code>let n = cast&lt;i64&gt;(net::subscribe("/hev/stats/power")?)?;
n + 1 + 1
</code></pre>
<p>The "arguments" to the function call were plugged into the holes in the graph
template and then the whole template is copied to the call site, and from then
on the graph runs as normal.</p>
<p>Lets revisit an earlier example where we used select and connect to find the
length of an array. Suppose we want to generalize that into a function,</p>
<pre><code>let len = |a: Array&lt;'a&gt;| {
  let sum = 0;
  select a {
    [x, tl..] =&gt; {
      sum &lt;- sum + 1;
      a &lt;- tl
    },
    _ =&gt; sum
  }
}
</code></pre>
<p>Lets just ignore the <code>'a</code> for now. Here we have a function that takes an array
with any element type and returns it's length. Brilliant, lets call it,</p>
<pre><code>let a = [1, 2, 3, 4, 5];
len(a)
</code></pre>
<p>and when we run this we get,</p>
<pre><code>eric@katana ~ [1]&gt; proj/graphix/target/debug/graphix ./test.gx
5
</code></pre>
<p>That's the right answer. Are we done? Noooooooo. No we are not done. Lets see
what happens if we do,</p>
<pre><code>let a = [1, 2, 3, 4, 5];
a &lt;- [1, 2, 3];
a &lt;- [1, 2];
len(a)
</code></pre>
<p>this results in,</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./test.gx
4
</code></pre>
<p>What!? That's not even wrong. That's just nonsense, what happened? The key to
understanding this problem is that there is just one call site, which means we
instantiated this little reusable bit of graph one time, just one time. That
means there is just one <code>sum</code>, one <code>a</code>, basically just one graph. When we use
connect to iterate we are using graph traversal cycles to do a new element of
the array every cycle until we are done. It will take 5 cycles for the first
array to be done, and that's the problem, because we update <code>a</code> with a whole new
array in cycle 1 and again in cycle 2. That's why we get 4, it's determanistic,
we will get 4 every time.</p>
<ul>
<li>the first cycle we add 1 to <code>sum</code> and set the inner <code>a</code> to <code>tl</code> (it's not the
same variable as the outer <code>a</code>, which is why the chaos isn't even greater). But
the outer <code>a</code> also gets set to <code>[1, 2, 3]</code> and that overwrites the inner set
because it happens after it (because that's just the way the runtime works).</li>
<li>the second cycle we add 1 to <code>sum</code> and set the inner <code>a</code> to <code>[2, 3]</code> and the
outer <code>a</code> to <code>[1, 2]</code></li>
<li>the third cycle we add 1 to <code>sum</code> and set the inner <code>a</code> to <code>[2]</code></li>
<li>the 4th cycle we add 1 to <code>sum</code> and set <code>a</code> to <code>[]</code></li>
<li>the 5th cycle we update our return value with <code>sum</code>, which is now 4</li>
</ul>
<p>We can only fix this be understanding that we're programming a graph. I tried to
make Graphix as much like a normal language as possible, but this is where we
depart from that possibility. The general idea is, we need to queue updates to
the outer <code>a</code> until we're done processing the current one. For that we have a
builtin called <code>queue</code>, here is the correct implementation</p>
<pre><code>let len = |a: Array&lt;'a&gt;| {
  let clock = once(null);
  let q = queue(#clock, a);
  let sum = 0;
  select q {
    [x, tl..] =&gt; {
      sum &lt;- sum + 1;
      q &lt;- tl
    },
    _ =&gt; {
      clock &lt;- null;
      sum &lt;- 0;
      once(sum)
    }
  }
}
</code></pre>
<p>Every time <code>clock</code> updates <code>queue</code> will output something it has queued, or if it
has nothing queued it will store that the next thing that arrives can go out
immediatly. So the first <code>a</code> will immediatly pass through the queue, but
anything after that will be held. Then the normal select loop will run, except
it will look at <code>q</code> instead of <code>a</code> now, so that <code>a</code> can update without
disturbing it. When we get to the terminating case, we update for next cycle
<code>clock</code> with <code>null</code> and <code>sum</code> with 0 and we return <code>once(sum)</code>. We return
<code>once(sum)</code> instead of just <code>sum</code> because removing something from the queue
takes one cycle, so it will be two cycles before we start on the next array, and
in the mean time the existing array will still be empty, meaning the second
select arm will still be selected, and <code>sum</code> is updating to 0 which we do not
want to return. If we run this with the same set of examples we will get the
correct answer,</p>
<pre><code>eric@katana ~&gt; proj/graphix/target/debug/graphix ./cycle_iter.gx
5
3
2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-defined-types"><a class="header" href="#user-defined-types">User Defined Types</a></h1>
<p>You can define your own data types in Graphix. This is useful for many tasks,
such as enforcing interface invariants, and modeling data. As a data modeling
language Graphix supports both structures, so called conjunctive types, where
you are modeling data that always appears together, and variants, or so called
disjunctive types, where a type can be one of many possible types drawn from a
set. This contrasts with other languages, for example Python, which only support
conjunctive types.</p>
<h2 id="structural-typing"><a class="header" href="#structural-typing">Structural Typing</a></h2>
<p>In most languages types are dealt with by name, meaning that two structs with
exactly the same fields are still different types if they have a different name.
The obvious implication of this is that all types need to be given a name, and
thus declared. Graphix works differently. Types in Graphix are structural,
meaning that types that are structurally the same are the same type. In fact
types in Graphix don't formally have names, there can be aliases for a large
type to cut down on verbosity, but an alias is always resolved to the structural
type when type checking. Because of this you don't need to declare types before
using them.</p>
<h2 id="set-based-type-system"><a class="header" href="#set-based-type-system">Set Based Type System</a></h2>
<p>The Graphix type system is based on set operations. For example, a function
could declare that it can take either an <code>i32</code> or an <code>i64</code> as an argument by
defining the set, <code>[i32, i64]</code> and annotating it's argument with this type.</p>
<pre><code>let f = |a: [i32, i64]| ...
</code></pre>
<p>When this function is called, the type checker will check that the type of
argument <code>a</code> is a subset of <code>[i32, i64]</code>, and will produce a type error if it is
not. Pretty much every operation the type checker performs in Graphix is one of,
or a combination of, simple set operations contains, union, difference, etc.</p>
<p>The combination of structural typing, set based type operations, and aggressive
type inference is meant to make Graphix feel like an untyped scripting language
most of the time, but still catch a lot of mistakes at compile time, and make it
possible to enforce interface contracts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Structs allow you to define a type that groups any number of fields together as
one data object. The fields are accessible by name anywhere in the program. For
example,</p>
<pre><code>{ foo: string, bar: i64 }
</code></pre>
<p>defines a struct with two fields, <code>foo</code> and <code>bar</code>. <code>foo</code> has type <code>string</code> and
<code>bar</code> has type <code>i64</code>. We can assign a struct of this type to a variable, and
pass it around just like any other data object. For example,</p>
<pre><code>let s = { foo: "I am foo", bar: 42 }
println("the struct s is [s]")
</code></pre>
<p>will print</p>
<pre><code>the struct s is {bar: 42, foo: "I am foo"}
</code></pre>
<h2 id="field-references"><a class="header" href="#field-references">Field References</a></h2>
<p>Struct fields can be referenced with the .field notation. That is,</p>
<pre><code>〉s.foo
-: string
"I am foo"
</code></pre>
<p>A more complex expression that results in a struct (such as a function call),
must be placed in parenthesis before the .field. For example,</p>
<pre><code>〉let f = || s
〉(f()).foo
-: string
"I am foo"
</code></pre>
<h2 id="mutability-and-functional-update"><a class="header" href="#mutability-and-functional-update">Mutability and Functional Update</a></h2>
<p>Structs are not mutable, like everything else in Graphix. However There is a
quick way create a new struct from an existing struct with only some fields
changed. This is called functional struct update syntax. For example,</p>
<pre><code>{ s with bar: 21 }
</code></pre>
<p>Will create a new struct with all the same fields as <code>s</code> except <code>bar</code> which will be set to 21. e.g.</p>
<pre><code>〉{ s with bar: 21 }
-: {bar: i64, foo: string}
{bar: 21, foo: "I am foo"}
</code></pre>
<p>Notice that the type printed is the full type of the struct, this is because of structural typing.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Structs are implemented as a sorted array of pairs, the field name being the
first element of the pair, and the data value being the second. The array is
sorted by the field name, and because of this it is not necessary to do any
matching when the field is accessed at run time, the index of the field
reference is pre computed at compile time, so field references are always O(1).
The reason why the fields are stored at all is so they can be used on the
network and in files without losing information. Because structs are array
backed, they are also memory pooled, and so making a new struct does not usually
allocate any memory, but instead reuses objects from the pool.</p>
<p>The <code>cast</code> operator can cast an unsorted array of pairs where the first element
is a string to a struct type. For example,</p>
<pre><code>〉cast&lt;{foo: string, bar: i64}&gt;([["foo", "I am foo"], ["bar", 42]])$
-: {bar: i64, foo: string}
{bar: 42, foo: "I am foo"}
</code></pre>
<p>Structs along with <code>cast</code> can be used to communicate complex values over the
network as long as the two sides agree on what the type is supposed to be.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variants"><a class="header" href="#variants">Variants</a></h1>
<p>Variants allow you to define a case that belongs to a set of possible cases a
value is allowed to be. For example we might categorize foods,</p>
<pre><code>[`Vegetable, `Fruit, `Meat, `Grain, `Other(string)]
</code></pre>
<p>Here we've defined a set of variants that together cover all the cases we want
to model. We can write a function that will only accept a member of this set,</p>
<pre><code>let f = |food: [`Vegetable, `Fruit, `Meat, `Grain, `Other(string)]| ...
</code></pre>
<p>and the type checker will ensure that it is an error caught at compile time to
pass any other type of value to this function. The most interesting variant in this set is probably</p>
<pre><code>`Other(string)
</code></pre>
<p>Because it carries data with it. Variant cases can carry an zero or more values
with them (types separated by commas, e.g. `Other(string, i64)). We can use
pattern matching to extract these values at run time. Lets write the body of our
food consuming function,</p>
<pre><code>let f = |food: [`Vegetable, `Fruit, `Meat, `Grain, `Other(string)]| select food {
  `Vegetable =&gt; "it's a vegetable",
  `Fruit =&gt; "it's a fruit",
  `Meat =&gt; "it's meat",
  `Grain =&gt; "it's grain",
  `Other(s) =&gt; "it's a [s]"
};
f(`Other("foo"))
</code></pre>
<p>If we copy the above into a file and run it we will get,</p>
<pre><code>eric@mazikeen ~/p/graphix (main) [1]&gt; target/debug/graphix ~/test.gx
"it's a foo"
</code></pre>
<p>In this example the type checker will ensure that,</p>
<ul>
<li>every item in the set is matched by a non guarded arm of the select (see the section on select)</li>
<li>no extra items that can't exist in the set are matched</li>
<li>you can't pass anything to f that isn't in the set</li>
</ul>
<p>Singleton variant cases like `Other(string) are actually a perfectly valid type
in Graphix, although they are much more useful in sets. Once we start naming
types (in a later section), they will become even more useful.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples-1"><a class="header" href="#tuples-1">Tuples</a></h1>
<p>Tuples are like structs where the field names are numbers, or like Arrays where
every element can be a different type and the length is known at compile time. For example,</p>
<pre><code>(string, i64, f64)
</code></pre>
<p>Is an example of a three tuple.</p>
<h2 id="field-accessors"><a class="header" href="#field-accessors">Field Accessors</a></h2>
<p>You can access the fields of a tuple by their field number, e.g. .0, .1, .2, etc.</p>
<pre><code>〉let t = (1, 2, 3)
〉t.0 == 1
-: bool
true
</code></pre>
<p>Tuple fields may also be bound in a pattern match in a let bind, a select arm, or a function argument. For example,</p>
<pre><code>〉let (f0, f1, f2) = t
〉f0
-: i64
1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="named-types"><a class="header" href="#named-types">Named Types</a></h1>
<p>You can name types to avoid having to type them more than once. Named types are
just aliases for the full structure of the type they reference. The fully
written out type is the same as the alias and visa versa. Lets go back to our
foods example from the section on variants.</p>
<pre><code>type FoodKind = [
  `Vegetable,
  `Fruit,
  `Meat,
  `Grain,
  `Other(string)
];

let v: FoodKind = `Vegetable;
let f = |food: FoodKind| ...
</code></pre>
<p>Aliases are very useful for more complex types that are used many times.
Selective annotations can also help the type checker make sense of complex
program structures.</p>
<p>In the next section you'll see that we can do a lot more with them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parametric-polymorphism"><a class="header" href="#parametric-polymorphism">Parametric Polymorphism</a></h1>
<p>We can define type variables as part of the definition of named types and then
use them in the type definition in order to create type aliases with type
parameters. For example, suppose in our foods example we wanted to specify that
`Other could carry a value other than a string,</p>
<pre><code>type FoodKind&lt;'a&gt; = [
  `Vegetable,
  `Fruit,
  `Meat,
  `Grain,
  `Other('a)
];
let v: FoodKind&lt;`Cookie&gt; = `Other(`Cookie);
v
</code></pre>
<p>if we paste this program into a file and run it we get,</p>
<pre><code>eric@mazikeen ~/p/graphix (main) [1]&gt; target/debug/graphix ~/test.gx
`Other(`Cookie)
</code></pre>
<p>We can even place constraints on the type that a type variable can take. For example,</p>
<pre><code>type Point3&lt;'a: Number&gt; = {x: 'a, y: 'a, z: 'a};
let f = |p: Point3&lt;'a&gt;, x: 'a| {p with x: p.x + x};
f({x: 0., y: 1., z: 3.14}, 1.)
</code></pre>
<p>Running this program we get,</p>
<pre><code>eric@mazikeen ~/p/graphix (main)&gt; target/debug/graphix ~/test.gx
{x: 0, y: 1, z: 3.14}
</code></pre>
<p>However, consider,</p>
<pre><code>type Point3&lt;'a: Number&gt; = {x: 'a, y: 'a, z: 'a};
let v: Point3&lt;'a&gt; = {x: "foo", y: "bar", z: "baz"};
v
</code></pre>
<p>Running this, we can see that <code>'a</code> is indeed constrained, since we get</p>
<pre><code>eric@mazikeen ~/p/graphix (main)&gt; target/debug/graphix ~/test.gx
Error: in file "/home/eric/test.gx"

Caused by:
    0: at: line: 2, column: 21, in: { x: "foo", y: "bar", z: "baz" }
    1: type mismatch Point3&lt;'a: [Int, Real]&gt; does not contain {x: string, y: string, z: string}
</code></pre>
<p>Indicating that we can't construct a Point3 with the type parameter of <code>string</code>,
because the constraint is violated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h1>
<p>Type aliases can be used to define recursive types, and this is a very powerful
modeling tool for repeating structure. If you want to see an advanced example
look no further than the <code>Tui</code> type in <code>graphix-shell</code>. Tui's are a set of
mutually recursive types that define the tree structure of a ui. For a less
overwelming example consider a classic,</p>
<pre><code>type List&lt;'a&gt; = [
  `Cons('a, List&lt;'a&gt;),
  `Nil
]
</code></pre>
<p>This defines a singly linked list as a set of two variant cases. Either the list
is empty (nil), or it is a cons cell with a <code>'a</code> and a list, which itself could
be either a cons cell or nil. If you've never heard the term "cons" and "nil"
they come from lisp, the original functional programming language from the late
1950s. Anyway, lets define some functions to work on our new list type,</p>
<pre><code>type List&lt;'a&gt; = [
  `Cons('a, List&lt;'a&gt;),
  `Nil
];

/// cons a new item on the head of the list
let cons = |l: List&lt;'a&gt;, v: 'a| -&gt; List&lt;'a&gt; `Cons(v, l);

/// compute the length of the list
let len = |l: List&lt;'a&gt;| {
  let rec len_int = |l: List&lt;'a&gt;, n: i64| select l {
    `Cons(_, tl) =&gt; len_int(tl, n + 1),
    `Nil =&gt; n
  };
  len_int(l, 0)
};

/// map f over the list
let rec map = |l: List&lt;'a&gt;, f: fn('a) -&gt; 'b| -&gt; List&lt;'b&gt; select l {
  `Cons(v, tl) =&gt; `Cons(f(v), map(tl, f)),
  `Nil =&gt; `Nil
};

/// fold f over the list
let rec fold = |l: List&lt;'a&gt;, init: 'b, f: fn('b, 'a) -&gt; 'b| -&gt; 'b select l {
  `Cons(v, tl) =&gt; fold(tl, f(init, v), f),
  `Nil =&gt; init
}
</code></pre>
<p>You can probably see where functional programming gets it's (partly deserved)
reputation for being elegant and simple. Lets try them out,</p>
<pre><code>let l = cons(cons(cons(cons(`Nil, 1), 2), 3), 4);
l
</code></pre>
<p>running this we get,</p>
<pre><code>eric@mazikeen ~/p/graphix (main) [1]&gt; target/debug/graphix ~/test.gx
`Cons(4, `Cons(3, `Cons(2, `Cons(1, `Nil))))
</code></pre>
<p>Lets try something more complex,</p>
<pre><code>map(l, |x| x * x)
</code></pre>
<p>results in</p>
<pre><code>eric@mazikeen ~/p/graphix (main)&gt; target/debug/graphix ~/test.gx
`Cons(16, `Cons(9, `Cons(4, `Cons(1, `Nil))))
</code></pre>
<p>as expected. Finally lets sum the list with fold,</p>
<pre><code>fold(l, 0, |acc, v| acc + v)
</code></pre>
<p>and as expected we get,</p>
<pre><code>eric@mazikeen ~/p/graphix (main)&gt; target/debug/graphix ~/test.gx
10
</code></pre>
<p>So with recursive types and recursive functions you can do some really powerful
things. When you add these capabilities to the data flow nature of Graphix, it
only multiplies the power even further.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>A reference value is not the thing itself, but a reference to it, just like a
pointer in C. This is kind of an odd thing to have in a very high level language
like Graphix, but there are good reasons for it. Before we get into those lets
see what one looks like.</p>
<pre><code>〉let v = &amp;1
〉v
-: &amp;i64
727
</code></pre>
<p>The <code>&amp;</code> in front of the <code>1</code> creates a reference. You can create a reference to
any value. Note that the type isn't <code>i64</code> anymore but <code>&amp;i64</code> indicating that <code>v</code>
is a reference to an <code>i64</code>. Just like a function when printed the reference id
is printed, not the value it refers to. We get the value that this reference 727
refers to with the deref operator *.</p>
<pre><code>〉*v
-: i64
1
</code></pre>
<h2 id="but-why"><a class="header" href="#but-why">But Why</a></h2>
<p>Now that we've got the basic semantics out of the way, what is this good for?
Suppose we have a large struct, with many fields, or even a struct of structs of
structs with a lot of data. And suppose every time that struct updates we do a
bunch of work. This is exactly how UIs are built by the way, they are deeply
nested tree of structs. Under the normal semantics of Graphix, if any field
anywhere in our large tree of structs were to update, then we'd rebuild the
entire object (or at least a substantial part of it), and any function that
depended on it would have no way of knowing what changed, and thus would have to
do whatever huge amount of work it is supposed to do all over again. Consider a
constrained GUI type with just labels and boxes,</p>
<pre><code>type Gui = [
  `Label(string),
  `Box(Array&lt;Gui&gt;)
]
</code></pre>
<p>So we can build labels in boxes, and we can nest the boxes, laying out the
labels however we like (use your imagination). We have the same problem as the
more abstract example above, if we were mapping this onto a stateful gui library
then every time a label text changed anywhere we'd have to destroy all the
widgets we had created and rebuild the entire UI from scratch. We'd like to be
able to just update the label text that changed, and we can, with a small change
to the type.</p>
<pre><code>type Gui = [
  `Label(&amp;string),
  `Box(Array&lt;Gui&gt;)
]
</code></pre>
<p>Now, the string inside the label is a reference instead of the actual string.
Since references are assigned an id at compile time, they never change, and so
the layout of our gui can never change just because a label text was updated.
Whatever is actually building the gui will only see an update to the root when
the actual layout changes. To handle the labels it can just deref the string
reference in each label, and when that updates it can update the text of the
label, exactly what we wanted.</p>
<h2 id="connect-deref"><a class="header" href="#connect-deref">Connect Deref</a></h2>
<p>Suppose we want to write a function that can update the value a passed in
reference refers to, instead of the reference itself (which we can also do). We
can do that with,</p>
<pre><code>*r &lt;- "new value"
</code></pre>
<p>Consider,</p>
<pre><code>let f = |x: &amp;i64| *x &lt;- once(*x) + 1;
let v = 0;
f(&amp;v);
println("[v]")
</code></pre>
<p>Running this program will output,</p>
<pre><code>eric@mazikeen ~/p/graphix (main) [1]&gt; target/debug/graphix ~/test.gx
0
1
</code></pre>
<p>We were able to pass <code>v</code> into <code>f</code> by reference and it was able to update it,
even though the original bind of <code>v</code> isn't even in a scope that <code>f</code> can see.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Graphix has a simple module system, with the minimal required functionality
necessary to organize code into a project.</p>
<p>The module system should be considered a work in progress, more features may be
added in the future. In particular there are a few unfinished parts,</p>
<ul>
<li>no module renaming on use</li>
<li>no access control, everything in a module is currently public</li>
</ul>
<p>These shortcomings may be fixed in a future release. Current features include,</p>
<ul>
<li>module hierarchies</li>
<li>inline modules (defined in the same file)</li>
<li>modules defined in external files</li>
<li>modules defined in netidx</li>
<li>modules dynamically loadable at runtime</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-modules"><a class="header" href="#inline-modules">Inline Modules</a></h1>
<p>In a single file, you can define modules inline. Expressions in modules are semi
colon separated. expressions defined in a module may be referred to directly
e.g. <code>m::name</code> or by bringing the module into scope with <code>use m</code>.</p>
<pre><code>mod m {
  let hello = "hello world";
  let goodbye = "goodbye world"
};

"we say [m::hello] followed by [m::goodbye]"
</code></pre>
<p>running this we get,</p>
<pre><code>eric@katana ~/p/graphix (main) [1]&gt; target/debug/graphix ~/test.gx
"we say hello world followed by goodbye world"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-modules"><a class="header" href="#external-modules">External Modules</a></h1>
<p>A simple external module may be defined in either a file or by a value in
netidx. In the case of a file, the file name must end in <code>.gx</code> and the part
before that is the name of the module. For example a file <code>m.gx</code> contains the
expressions defining the module <code>m</code>. Expressions in the file do not need to be
surrounded by a <code>mod m { ... }</code>, the name of the module is taken from the
filename.</p>
<p>In netidx, a string value containing Graphix source is published, and the final
name in the path is the name of the module, no <code>.gx</code> is required for netidx
modules. For example we might publish <code>/libs/graphix/strops</code>, the name of the
module would be <code>strops</code>, and the resolver expects it to be a string containing
valid Graphix code, just like a file.</p>
<p>Here is a simple example with file modules,</p>
<pre><code>eric@katana ~/t/ex&gt; ls
m.gx  test.gx
</code></pre>
<p><code>test.gx</code> is the program that we will run, <code>m.gx</code> is a module it will load.</p>
<p><code>test.gx</code></p>
<pre><code>mod m;

m::hello
</code></pre>
<p><code>m.gx</code></p>
<pre><code>let hello = "hello world"
</code></pre>
<p>running this we get,</p>
<pre><code>eric@katana ~/p/graphix (main)&gt; target/debug/graphix ~/tmp/ex/test.gx
"hello world"
</code></pre>
<h2 id="module-load-path"><a class="header" href="#module-load-path">Module Load Path</a></h2>
<p>The graphix shell reads the <code>GRAPHIX_MODPATH</code> environment variable at startup
and appends it's contents to the built in list of module paths. The syntax is a
comma separated list of paths. Paths that start with <code>netidx:</code> are netidx paths,
otherwise file paths are expected. The comma separator can be escaped with <code>\</code>.
For example,</p>
<pre><code>GRAPHIX_MODPATH=netidx:/foo,/home/eric/graphix-modules,/very/str\,ange/path
</code></pre>
<p>would add</p>
<ul>
<li>netidx:/foo</li>
<li>/home/eric/graphix-modules</li>
<li>/very/str,ange/path</li>
</ul>
<p>to the Graphix module path</p>
<h3 id="default-module-path"><a class="header" href="#default-module-path">Default Module Path</a></h3>
<p>By default the module resolve path has several entries,</p>
<ul>
<li>
<p>the parent directory of the program file passed on the command line. e.g. if
we are running <code>/home/eric/test.gx</code> then Graphix will look for modules in
<code>/home/eric</code></p>
</li>
<li>
<p>the Graphix init directory. This is a platform specific directory where you
can put Graphix modules.</p>
<ul>
<li>On Linux <code>~/.local/share/graphix</code></li>
<li>On Windows <code>%APPDATA%\Roaming\graphix</code></li>
<li>On Mac OS <code>~/Library/Application Support/graphix</code></li>
</ul>
</li>
</ul>
<p>In REPL mode, which is when it's given no argument, the <code>graphix</code> command will
try to load the module <code>init</code>. If no such module exists it will silently carry
on. You can use this to load commonly used utilities in the repl automatically.</p>
<h2 id="modules-in-netidx"><a class="header" href="#modules-in-netidx">Modules in Netidx</a></h2>
<p>We can publish the same code as the files example in netidx and use it in
Graphix directly, but we have to run it in a slightly different way, first lets
publish it,</p>
<pre><code>eric@katana ~/t/ex&gt; printf \
  "/local/graphix/test|string|%s\n/local/graphix/m|string|%s" \
  "$(tr \n ' ' &lt;test.gx)" "$(tr \n ' ' &lt;m.gx)" \
  | netidx publisher
</code></pre>
<p>Graphix doesn't care about whitespaces like newline, so we can just translate
them to spaces to avoid confusing the command line publisher. Lets see if we
published successfully.</p>
<pre><code>eric@katana ~&gt; netidx subscriber /local/graphix/test
/local/graphix/test|string|"mod m;  m::hello"
</code></pre>
<p>Looks good, now lets run the code. In order to do this we need to add to the
resolve path to tell the Graphix shell where it should look for modules. We also
don't pass a <code>.gx</code> extension, so we are telling Graphix to look for a module
named <code>test</code> in it's configured module paths and run that.</p>
<pre><code>eric@katana ~/p/graphix (main)&gt; GRAPHIX_MODPATH=netidx:/local/graphix \
  target/debug/graphix test
"hello world"
</code></pre>
<h2 id="module-hierarchies"><a class="header" href="#module-hierarchies">Module Hierarchies</a></h2>
<p>Module hierarchies can be created using directories, for example to create
<code>m::n</code> you would create a directory <code>m</code> and in it a file called <code>mod.gx</code> and a
file called <code>n.gx</code></p>
<pre><code>eric@katana ~/t/ex1&gt; find .
.
./m
./m/mod.gx
./m/n.gx
./test.gx
</code></pre>
<p><code>test.gx</code> is the root of the hierarchy</p>
<pre><code>mod m;

m::n::hello
</code></pre>
<p><code>m/mod.gx</code> is the root of module <code>m</code></p>
<pre><code>mod n
</code></pre>
<p><code>m/n.gx</code> is the <code>m::n</code> module</p>
<pre><code>let hello = "hello world"
</code></pre>
<p>if we run the program we get,</p>
<pre><code>eric@katana ~/p/graphix (main)&gt; target/debug/graphix ~/tmp/ex1/test.gx
"hello world"
</code></pre>
<h2 id="module-hierarchies-in-netidx"><a class="header" href="#module-hierarchies-in-netidx">Module Hierarchies in Netidx</a></h2>
<p>Module hierarchies in netidx work the same as in the file system except that
<code>mod.gx</code> is never needed because in <code>netidx</code> a value can also be a container. So
to replicate the above example we'd publish,</p>
<pre><code>/lib/graphix/test &lt;- the contents of test.gx
/lib/graphix/m    &lt;- the contents of m/mod.gx
/lib/graphix/m/n  &lt;- the contents of m/n.gx
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-modules"><a class="header" href="#dynamic-modules">Dynamic Modules</a></h1>
<p>Graphix programs can dynamically load modules at runtime. The loaded code will
be compiled, type checked, and the loader will return an error indicating any
failure in that process. Because Graphix is a statically typed language we must
know ahead of time what interface the dynamically loaded module will have. We do
this by defining a module signature. We can also define what the dynamically
loaded module is allowed to reference, in order to prevent it from just calling
any function it likes (aka it's sandboxed). Lets dive right in with an example,</p>
<pre><code>// the module source, which we will publish in netidx
let path = "/local/foo";
let source = "
    let add = |x| x + 1;
    let sub = |x| x - 1;
    let cfg = \[1, 2, 3, 4, 5\];
    let hidden = 42
";
net::publish(path, source)$;

// now load the module
let status = mod foo dynamic {
    sandbox whitelist [core];
    sig {
        val add: fn(i64) -&gt; i64;
        val sub: fn(i64) -&gt; i64;
        val cfg: Array&lt;i64&gt;
    };
    source cast&lt;string&gt;(net::subscribe(path)$)$
};
select status {
    error as e =&gt; never(dbg(e)),
    null as _ =&gt; foo::add(foo::cfg[0]$)
}
</code></pre>
<p>running this we get,</p>
<pre><code>eric@katana ~/p/graphix (main)&gt; target/debug/graphix ~/test.gx
2
</code></pre>
<p>In the first part of this program we just publish a string containing the source
code of the module we want to ultimatly load. The second part is where it gets
interesting, lets break it down.</p>
<p><code>mod foo dynamic</code> declares a dynamically loaded module named <code>foo</code>. In the rest
of our code we can refer (statically) to <code>foo</code> as if it was a normal module that
we loaded at compile time. There are three sections required to define a dynamic
module, they are required to be defined in order, sandbox, sig, and source,</p>
<ul>
<li>a <code>sandbox</code> statement, of which there are three types
<ul>
<li><code>sandbox unrestricted;</code> no sandboxing, the dynamic module can access
anything in it's scope</li>
<li><code>sandbox whitelist [item0, item1, ...]</code> the dynamic module may access ONLY
the names explicitly listed. e.g. <code>sandbox whitelist [core::array];</code> would
allow the dynamic module to access only <code>core::array</code> and nothing else.</li>
<li><code>sandbox blacklist [item0, item1, ...]</code> the dynamic module may access
anything except the names listed. <code>sandbox blacklist [super::secret::module];</code> everything except super secret module would be
accessible</li>
</ul>
</li>
<li>a <code>sig</code> statement is the type signature of the module. This is a special
syntax for writing module type signatures. There are three possible statements,
<ul>
<li>a val statement defines a value and it's type, <code>val add: fn(i64) -&gt; i64</code> is
an example of a val statement, it need not be a function it can be any type</li>
<li>a type statement defines a type in the loaded module, e.g. <code>type T = { foo: string, bar: string }</code> val statements that come after a type statement may
use the defined type. The type statement is identical to the normal type
statement in Graphix (so it can be polymorphic, recursive, etc).</li>
<li>a mod statement defines a sub module of the dynamically loaded module. A sub
module must have a sig. <code>mod m: sig { ... }</code> defines a sub module.</li>
</ul>
</li>
<li>a <code>source</code> statement defines where the source code for the dynamic module will
come from. It's type must be a string.</li>
</ul>
<p>The <code>mod foo dynamic ...</code> expression returns a value of type,</p>
<p><code>[null, Error&lt;`DynamicLoadError(string)&gt;]</code></p>
<p>The runtime will try to load the module every time the source updates. If it
succeeds it will update with <code>null</code>, if it fails it will update with an error
indicating what went wrong, and the previous loaded module (if any) will still
be accessible. If compilation succeeds the previous loaded module will be
deleted and replaced with the new one, and the new module will be initialized,
possibly causing values it exports to update.</p>
<p>Obviously the loaded module must match the type signature defined in the dynamic
mod statement. However, the signature checking only cares that every item
mentioned in the signature is present in the dynamic module and that the types
match. If extra items are present in the dynamic module they will simply be
ignored, and will be inaccessible to the loading program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-standard-library"><a class="header" href="#the-standard-library">The Standard Library</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core"><a class="header" href="#core">core</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net"><a class="header" href="#net">net</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-1"><a class="header" href="#array-1">array</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="str"><a class="header" href="#str">str</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="re"><a class="header" href="#re">re</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time"><a class="header" href="#time">time</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rand"><a class="header" href="#rand">rand</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-uis-with-graphix"><a class="header" href="#building-uis-with-graphix">Building UIs With Graphix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuis"><a class="header" href="#tuis">TUIs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="barchart"><a class="header" href="#barchart">barchart</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block"><a class="header" href="#block">block</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="browser"><a class="header" href="#browser">browser</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calendar"><a class="header" href="#calendar">calendar</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas"><a class="header" href="#canvas">canvas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chart"><a class="header" href="#chart">chart</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">text</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paragraph"><a class="header" href="#paragraph">paragraph</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gauge"><a class="header" href="#gauge">gauge</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linegauge"><a class="header" href="#linegauge">linegauge</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">layout</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list"><a class="header" href="#list">list</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll"><a class="header" href="#scroll">scroll</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparkline"><a class="header" href="#sparkline">sparkline</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table"><a class="header" href="#table">table</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tabs"><a class="header" href="#tabs">tabs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-graphix"><a class="header" href="#embedding-graphix">Embedding Graphix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-built-in-functions"><a class="header" href="#writing-built-in-functions">Writing Built in Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-graphix-shell"><a class="header" href="#using-graphix-shell">Using graphix-shell</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-graphix-rt"><a class="header" href="#using-graphix-rt">Using graphix-rt</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
