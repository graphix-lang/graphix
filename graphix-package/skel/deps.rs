// This file is automatically generated by the package manager, do not edit it

use anyhow::Result;
use arcstr::ArcStr;
use fxhash::FxHashMap;
use graphix_compiler::{env::Env, ExecCtx};
use graphix_package::{CustomDisplay, Package};
use graphix_rt::{CompExp, GXExt, GXHandle, GXRt};
use netidx_core::path::Path;
use tokio::sync::oneshot;

pub(crate) fn register<X: GXExt>(
    ctx: &mut ExecCtx<GXRt<X>, X::UserEvent>,
    modules: &mut FxHashMap<Path, ArcStr>,
) -> Result<ArcStr> {
    {{#each deps}}
    {{this.crate_name}}::P::register(ctx, modules)?;
    {{/each}}
    Ok(ArcStr::from("{{root_expr}}"))
}

pub(crate) struct Cdc<X: GXExt> {
    pub stop: oneshot::Receiver<()>,
    pub custom: Box<dyn CustomDisplay<X>>,
}

pub(crate) enum CustomResult<X: GXExt> {
    Custom(Cdc<X>),
    NotCustom(CompExp<X>),
}

pub(crate) fn maybe_init_custom<X: GXExt>(
    gx: &GXHandle<X>,
    env: &Env,
    e: CompExp<X>,
) -> Result<CustomResult<X>> {
    {{#each deps}}
    if {{this.crate_name}}::P::is_custom(gx, env, &e) {
        let (tx, rx) = oneshot::channel();
        return {{this.crate_name}}::P::init_custom(gx, env, tx, e)
            .map(|custom| CustomResult::Custom(Cdc { stop: rx, custom }));
    }
    {{/each}}
    Ok(CustomResult::NotCustom(e))
}
